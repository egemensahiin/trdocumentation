* Bilgisayar
Bilgisyar, dış dünyadan aldığı verileri aritmetik ve mantıksal olarak
işleyebilen ve bu işlen sonuçlarını yazılı veya görüntülü olarak bildiren,
istenildiğinde istendiği kadar saklayabilen elektronik bir makinedir.
bilgisayar yapısı itibarıyla donanım ve yazılım olmak üzere ikiye ayrılır.

** Donanım:
Bilgisayarın fiziksel parçalarıdır. Bilgisayarın gözle görülen bütün
parçaları donanım olarak isimlendirilir.
            
:                    |--------------|
:                    | Bellek       |
:                    | (Memory)     |
:                    |--------------|
:                        ▲    |
:                        |    |
:                        |    ▼ 
: |----------|       |--------------|       |-----------|
: | Giriş    |       | İşlem        |       | Çıkış     |
: | (Input)  | ---▶  | (Process)    | ---▶  | (Output)  |
: |----------|       |--------------|       |-----------|
Donanım sisteminin blok gösterimi

*** 1-Giriş (Input):
Bilgisayarın dış dünyadan veri alabildiği birimlerdir. /Klavye, fare, ışık/
/kalemleri, mikrofon, tarayıcı/ gibi donanım parçaları örnek olarak
verilebilir.
      
*** 2-Çıkış (Output):
Bilgisyarın depoladığı verileri veya işlem sonuçlarını bildirmek için
kullandığı aygıtlardır. /Ekran, yazıcı, çizici, hoparlör/ örnek olarak
verilebilir.

*** 3-İşlem (Process):
Bilgisayardaki bütün aritmetiksel, mantıksal ve kontrol işlemleri *CPU*
(Central Processing Unit/Merkezi İşlem Birimi) tarafından yapılır. CPU
bilgisayarın beynidir demek yanlış olmaz. /İşlemci/ veya /mikroişlemci/
olarak da adlandırılmaktadır.

Mikroişlemciler içersinde aritmetik ve mantıksal işlemleri yapan *ALU*
(Arithmetic Logic Unit) ve denetim işlemlerini gerçekleştiren *CU* (Control
Unit) bulunur.
      
*** 4-Bellek (Memory):
Bilgileri saklayan birimlerdir. Bilgisayar içersinde iki çeşit bellek
bulunur; ana bellek ve yan bellek. Belleklerin en büyük özelliği,
saklayabildikleri bilginin miktarı başka bir deyişle kapasiteleridir.

**** 4.1-Ana bellek (Main memory):
RAM ve ROM olmak üzere iki adettir.
*RAM (Random Access Memory)*: Bilgisayar açık kaldığı sürece üzerinde
çalışılan bilgileri saklamak için kullanılan bellek türüdür. Geçici bellek
olarak da düşünülebilir. Elektrik kesilmesi veya bilgisayarın kapatılması
durumunda kaydedilen bilgiler kaybolur. Bellek denildiğinde RAM
anlaşılmaktadır.
*ROM (Read Only Memory)*: Üretici firma tarafından bilgisayarın çalışması
için gerekli olan bilgileri kaydetmek için kullanılır. Kullanıcının
müdahalesi söz konusu değildir, yazma yetkisi yoktur. Adından da
anlaşılabileceği gibi üzerindeki bilgiler sadece okunur.

**** 4.2-Yan bellek (Secondary storage devices):
Kullanıcı bilgilerinin istenildiği gibi saklanabildiği manyetik veya fiziksel
depolama ortamıdır. Bilgisayar içindeki /sabit disk (harddisk), taşınabilen/
/disket, CD-ROM/ örnektir.

Bilgiler bellekte saklanırken elektriksel sinyaller olarak saklanır ve bu
bilgilerin her birine /bit (Binary digit)/ adı verilir. Bitler sinyalin 1 mi
yoksa 0 mı olduğunu ifade ederler çünkü bilgisayarın içersinde işlenen bütün
bilgiler 1 ve 0'lardan oluşan bit dizileri ile ifade edilirler. Bu bitlerin 8
tanesi bir araya gelerek en küçük bilgi birimi olan /byte/'ları oluştururlar.
Örneğin bir "A" harfi bellekte tutulmak istenirse önce bu harfe karşılık
gelen standart bir kod (ASCII: American Standart Code Information
Interchange) üretilir. Bu kod on tabanında yazılmış bir sayı olup onluk
sistemden ikilik (binary) sisteme çevrildiğinde 1 ve 0'lardan oluşan bir
sayısal değer ortaya çıkar.

|------+------------+-------------|
| Harf | ASCII code | Binary code |
|------+------------+-------------|
| A    | 65         | 01000001    |
|------+------------+-------------|

Diğer ölçü birimlerindeki gibi byte'ların da üst katları vardır:

| 1024 byte | 1 Kilobyte (KB) |
| 1024 KB   | 1 Megabyte (MB) |
| 1024 MB   | 1 Gigabyte (GB) |
| 1024 GB   | 1 Terabyte (TB) |

*** 5-Modem:
Modulation-demodulation kelimelerinden türetilmiştir. Bilgisayarların telefon
hatları üzerinden iletişim kurması için kullanılır. Hem bir giriş hem de bir
çıkış birimidir.

** Yazılım (Software):
Yazılım, bilgisayarın çalışmasını sağlayan programların tamamıdır. Donanıma
iş yaptıran bölüm yazılımdır ve 3'e ayrılır.

*** 1-İşletim Sistemleri (Operating System):
Bilgisayarın donanımı ile kullanıcı arasındaki iletişimi sayğlayan
programların oluşturduğu bütündür. Diğer yazılımlar işletim sistemine,
işletim sistemi de donanıma emir verir. Bir işletim sistemi fonksiyonel
olarak kabuk (shell) ve çekirdek (kernel) olmak üzere ikiye ayrılır. Çekirdek
bilgisayarın donanımını yönetirken kabuk ise kullanıcıya bir arabirim sunarak
komutları yorumlar.

*** 2-Paket Programlar (Application Software):
Kullanıcının isteklerine göre hazırlanmış özel amaçlı yazılımlardır. Yazım
editörleri (vim, emacs, notpad++ vb.), döküman editörleri (LibreOffice,
Microsoft Office vb.) ve hatta oyunlar bu tip yazılımlara örnektir.

*** 3-Programlama dilleri:
Yazılımları geliştirmek için gerekli olan programlardır. Yazılımlar bu tür
programlar sayesinde programcılar tarafından geliştirilirler. Programlama
dilleri 3 sınıfta incelenirler.

**** 3.1-Makine Dili (Machine Language):
Sadece bilgisayarın donanımı tarafından anlaşılabilen ikili sayı kodlarından
oluşan programlar yazılabilir. Standardize edilmemiştir. Her CPU'da ayrı bir
makine kodu kullanılır. Programcılar için yazılması zordur.

**** 3.2-Assembly Language:
Bu dilde ikili kodların yerini, İngilizce kelimelerden esinlenilmiş
komut kodları bulunur. Örneğin toplama için /ADD/, dallanma için /JMP/,
çağırmak için /LOAD/ vb. Oluşturulan komut listeleri "Assembler" adı verilen
çevirici programlarla makine koduna çevrilmektedir. Bu dil de programcılar
için zahmetli ve yavaş yazılan bir dildir.

**** 3.3-Yüksek Seviye Diller (High Level Languages):
Assembly dilinin sınırlılıkları, yüksek seviye dillerin ortaya çıkmasına
sebep olmuştur. Bu dillerde daha az kod yazarak daha fazla iş yaptırmak
mümkün hale gelmiş, yazılan kodların anlaşılırlığı artmıştır. Bazı örnekler
aşağıda verilmiştir.

|---------+----------------------------------|
| İsim    | Kullanım alanları                |
|---------+----------------------------------|
| FORTRAN | Bilimsel programlama             |
|---------+----------------------------------|
| LISP    | Yapay zeka programlama           |
|---------+----------------------------------|
| COBOL   | Ticari veri işleme               |
|---------+----------------------------------|
| PROLOG  | Yapay zeka programlama           |
|---------+----------------------------------|
| C       | Sistem programlama               |
|---------+----------------------------------|
| C++     | Obje odaklı programlama          |
|---------+----------------------------------|
| ADA     | Gerçek zamanlı dağıtık sistemler |
|---------+----------------------------------|
| Python  | Obje odaklı programlama          |
|---------+----------------------------------|

* Programlama ile ilgili kavramlar

** Program ve program oluşum safhaları

*** 1-Kaynak Kod (Source Code):
Programın herhangi bir programlama dilinin kurallarına göre, o programlama
dilinin komutları ile oluşturulmuş ilk haline kaynak kod veya kaynak dosya
denir. Kaynak kodları esasında metin editörlerinde yazılmış düz metinlerdir.
genellikle programlama dillerine göre farklı uzantılarla adlandırılırlar (C
dilince .c, pythonda .py gibi).

*** 2-Derleyici (Compiler):
Metin halinde yazılan kaynak kodunun CPU tarafından çalıştırılabilmesi için
binary formatındaki makine koduna çevrilmesi yani /compile/ edilmesi gerekir.
Bunun için de *derleyiciler (compiler)* kullanılır. Derleyiciler, verilen
kaynak kodunu makine koduna çevirerek amaç dosyasını/kodunu (object file)
üretir. Bu dosya artık ikili kod biçimindedir ve bu sebeple *binary* olarak
adlandırılır.

Derleme işlemi esnasında belli hatalar alınabilir. Bu hatalar üç kategoride
incelenir.

**** 2.1-Derleme zamanı hataları (Compile Time Error):
Genellikle kullanılan dilin syntax'ına (gramer kurallarına) uyulmadığında,
komutlar yanlış yazıldığında veya uygun olmayan karakterler kullanıldığında
karşılaşılan hatalardır. Bu tip hatalardan bir tane bile alınması durumunda
program derlenemez, amaç kod oluşmaz.

**** 2.2-Çalışma zamanı hataları (Run Time Error):
Program kurallara uygun olarak yazılmıştır ve herhangi bir yazım hatası
bulunmaz. Çalışabilir bir uygulama haline getirilmiştir fakat çalışma anında
bir takım veriler ya da uygun olmayan ortamlar nedeniyle çalışma anında bu
tip hatalarla karşılaşılır. En iyi örneklerden biri sıfıra bölme hatasıdır.

**** 2.3-Mantıksal Hatalar (Logical Error):
Programcının çözüm için gerekli adımların oluşturmasında, çözüm yönteminin
yanlış olmasından ya da yanlış işleçlerin kullanılmasından kaynaklanır.
Örneğin ">" yerine "<" kullanıldığında ne bir derleme hatası alınır ne de
derlenen program çalışırken bir çalışma hatası alınır fakat programın
çalışması sonucunda istenen işler yapılmaz/yanlış yapılır ve dolayısıyla
uygun çıktılar üretilemez.

* C ile programlamanın temelleri

** C programlarının temel yapısı:
Bir C programı iki temel bölümden oluşur: Önişlemci direktifleri
(Preprocessor Directives) ve Ana fonksiyon (main function)

- *Önişlemci Direktifleri*: "#" ile başlar ve program derlenmeden önce C
  önişlemcisi tarafından işletilir. Herbirinin farklı görevleri vardır. En sık
  kullanılan iki direktif *#include* ve *#define*'dır. C dilinde kullanılan her
  işlev, C'nin temel yapısı içersinde yer almaz. Bu nedenle program içinde
  kullanılan fonksiyonların kendilerinin ya da prototiplerinin yer aldığı
  dosyalar (diğer bir deyişle kütüphaneler), *#include* direktifi kullanılarak
  programa dahil edilir. Örneğin *printf* fonksiyonunun prototipi, *stdio.h*
  içersinde bulunmaktadır. Dolayısıyle eğer *printf* kullanılacaksa, *stdio.h*
  (standart input-output) kütüphanesi *#include* direktifiyle dahil
  edilmelidir. ".h" uzantılı bu dosyalar C programlama dilinde /başlık/
  /(header)/ dosyaları adı verilir.

- *Main Fonksiyonu*: C dilinde yazılmış programlar genellikle birden fazla
  fonksiyondan oluşurlar. *main()* fonksiyonu, bütün C programlarında bulunması
  gereken ana fonksiyondur yani programın gövdesidir. Program çalıştırılırken
  ilk çalışacak olan fonksiyondur. Çalıştırılacak olan /ifadeler (statements)/
  *main()* fonksiyonu içersine *{}* arasına yazılır. Açılan her kıvrık parantez
  mutlaka kapatılmalıdır. Arada kalan bölüme /blok/ adı verilir. En dıştaki
  blok programın ana kısmı olup iki bölümden oluşur: *Bildiriler*
  *(declerations)* ve *İşletilenilir İfadeler (executable statements)*.
  Bildiriler programda kullanılacak değişkenlerin adlarını belirlemek amacıyla
  yazılırken işletilebilir ifadeler yapılan işlemleri yerine getiren
  komutlardır.

** Basit bir C programı
Basit bir C programında tüm bu bileşenleri görelim:
#+BEGIN_SRC c

/* C programlarında yorumlar bu şekilde yazılır */
// Bu satır da bir yorumdur.
#include <stdio.h>

int main()
{
      printf("Merhaba Dünya");
      return 0;
}

#+END_SRC

** C dilinde genel yazım kuralları
- C dili birden çok satırdan oluşan yorumlara izin verir. Tüm bir satırın
  yorumlanması için başına "//" getirilir. Eğer birden fazla satır
  yorumlanmak isteniyorsa veya yorum bittikten sonra kod yazılacaksa "/* */"
  arasına yazılır.
- C'de işletilebilir her ifade, ";" ile sonlandırılır. Bir satıra birden
  fazla ifade yazılabilir ancak önişlemci direktifleri, mutlaka her satırda
  yalnızca bir tane olacak şekilde yazılmalıdır.
- C'de bütün anahtar kelimeler ve komutlar küçük harfle yazılır (*#define*
  direktifi hariç). C büyük-küçük harf duyarlı bir dildir yani "TOPLAM",
  "toplam" ve "topLAM" kelimelerinin hepsi C derleyicisi tarafından farklı
  anlaşılır.
- Program yazım kuralları dahilinde olmasa da okunabilirliği arttırmak için
  bloklar içersine yazılan ifadelerin bir tab veya 3-4 boşluk içerden
  yazılmasına özen gösterilmelidir.
  *İyi bir yazım*:
  #+BEGIN_SRC c
  int main()
  {
      /*.............*/;
      /*.............*/;
      {
            /*.............*/;
            {
                  /*.............*/;
                  /*.............*/;
            }
            /*.............*/;
            /*.............*/;
      }
      /*.............*/;
  }
  #+END_SRC
  *Kötü bir yazım*:
  #+BEGIN_SRC c
  int main()
  {
  /*.............*/;
  /*.............*/;
  {
  /*.............*/;
  {
  /*.............*/;
  /*.............*/;
  }
  /*.............*/;
  /*.............*/;
  }
  /*.............*/;
  }
  #+END_SRC

** İşleçler (Operatörler)
İşleçler matematiksel, mantıksal ve atama işlemlerini gerçekleştirmek için
kullanılan simgelerdir. Bunlar ile işleme giren değerlere /işlenen (operand)/
adı verilir. C dilinde kullanılan operatörler üç grupta incelenir.

*** 1-Matematiksel İşleçler:
|---------------+---------------------|
| İşlem         | C dilinde karşılığı |
|---------------+---------------------|
| Çarpma        | *                   |
| Modüler bölüm | %                   |
| Bölme         | /                   |
| Toplama       | +                   |
| Çıkarma       | -                   |
| Bir arttırma  | ++                  |
| Bir eksiltme  | --                  |
|---------------+---------------------|

Bir arttırma ve bir eksiltme operatörlerinin farklı kullanımları vardır.
Yalnız başlarına kullanıldıklarında sonuç değişmez; beraber kullanıldıkları
değişkenin önüne ya da arkasına yazıldıklarında değerini bir arttırır ya da
azaltırlar. Ancak bir işlem içinde kullanımlarında değişkenin sağı veya
solunda yazılmaları işlem sonucunu değiştirir:
|---------------------+--------------------------------------------------------|
| Yazım biçimi        | Anlamı                                                 |
|---------------------+--------------------------------------------------------|
| a++ (postincrement) | Önce a'yı kullan sonra içindeki değeri 1 arttır.       |
| ++a (preincrement)  | Önce a'yı 1 arttır, sonra bu arttırılmış değeri kullan |
| a-- (postdecrement) | Önce a'yı kullan sonra içindeki değeri 1 eksilt.       |
| --a (predecrement)  | Önce a'yı 1 eksilt, sonra bu arttırılmış değeri kullan |
|---------------------+--------------------------------------------------------|

Mesela 3 değişkenli bir durumda farklı senaryoları inceleyelim. *a = 4*
olsun:
|-------------+-------------------------------+--------------|
| İşem        | İşlemlerin gerçekleşme sırası | Son değerler |
|-------------+-------------------------------+--------------|
| c = a++ * 5 | 1. c = a*b = 4*5 = 20         | a = 5        |
|             | 2. a = a+1 = 4+1 = 5          | c = 20       |
|-------------+-------------------------------+--------------|
| c = ++a * 5 | 1. a = a+1 = 4+1 = 5          | a = 5        |
|             | 2. c = a*b = 5*5 = 25         | c = 25       |
|-------------+-------------------------------+--------------|
| c = a-- * 5 | 1. c = a*b = 4*5 = 20         | a = 3        |
|             | 2. a = a-1 = 4-1 = 3          | c = 20       |
|-------------+-------------------------------+--------------|
| c = ++a * 5 | 1. a = a-1 = 4-1 = 3          | a = 3        |
|             | 2. c = a*b = 3*5 = 15         | c = 15       |
|-------------+-------------------------------+--------------|

Esasında bu tip karışık ifadelerden kaçınmak en doğrusudur. Derleyici hem
pre hem de post increment veya decrement yapabildiği için programcı bunların
kullanımında çok dikkatli olmalıdır. Özensiz veya hızlı bir yazımda kolayca
hata yapılabilir.

*** 2-Mantıksal İşleçler:
|----------------------+-----------------------|
| İşlem                | C dilindeki karşılığı |
|----------------------+-----------------------|
| Büyük                | >                     |
| Büyük veya eşit      | >=                    |
| Küçük                | <                     |
| Küçük veya eşit      | <=                    |
| Eşit (karşılaştırma) | ==                    |
| Eşit değil           | !=                    |
| Ve (And)             | &&                    |
| Veya (Or)            | \vert \vert           |
| Değil                | !                     |
|----------------------+-----------------------|

*** 3-Atama İşleçleri:
|-------+------------------|
| İşleç | Anlamı           |
|-------+------------------|
| =     | Atama            |
| +=    | Toplayarak atama |
| -=    | Eksilterek atama |
| *=    | Çarparak atama   |
| /=    | Bölerek atama    |
| %=    | Mod alarak atama |
|-------+------------------|

*** İşleçlerin Öncelik Sırası
|---------+-----------------+------------------------------------|
| Öncelik | İşleç           | Aynı önceliğe sahip olanlarda sıra |
|---------+-----------------+------------------------------------|
| 1       | ()              | Soldan sağa                        |
| 2       | ++, -- ve !     | Sağdan sola                        |
| 3       | *, / ve %       | Soldan sağa                        |
| 4       | + ve -          | Soldan sağa                        |
| 5       | <, >, <= ve >=  | Soldan sağa                        |
| 6       | == ve !=        | Soldan sağa                        |
| 7       | &&              | Soldan sağa                        |
| 8       | \vert \vert     | Soldan sağa                        |
| 9       | Atama işleçleri | Sağdan sola                        |
|---------+-----------------+------------------------------------|

** Değişkenlerin tanımlanması ve veri türleri
Kullanılacak bütün değişkenlerin *kullanılmadan önce* C derleyicisine
bildirilmeleri gerekir. Derleyiciye değişkenleri bildirme işine /değişken/
/tanımlamak/ denir. Değişken tanımlamak, değişken için bir isim seçerek ve
içersinde ne tür bir veri saklayacağını söyleyerek yapılır. Değişkenlerin üç
özelliği vardır: ismi, veri türü ve değeri.
- *İsim*: Değişkeni saklamak için ayrılmış bellek hücresine verilen isimdir.
- *Veri Türü*: Saklanan bilginin türüdür (ondalık sayı, tam sayı, karakter vb)
- *Değer*: Değişken içersinde saklanan bilginin kendisi.

*** Değişkenlerin isimlendirilmesi:
Program içersindeki değişkenlerin isimleri programcı tarafından belirlenir
fakat belli kurallara uyulması gerekir.
+ Her programlama dilinin kendine ait *ayrılmış isimleri* vardır. Bunlar
  program içersindeki komutları, özel değişkenleri vb içerir.

|----------+--------+---------+-----------+--------+--------+---------+----------+---------|
| Asm      | auto   | break   | case      | cdecl  | Char   | const   | continue | default |
| Do       | double | else    | enum      | extern | far    | float   | for      | goto    |
| huge     | if     | int     | interrupt | long   | near   | pascal  | register | return  |
| short    | signed | sizeof  | static    | struct | switch | typedef | union    | void    |
| volatile | while  | fortran | _CS       | _BP    | _DI    | _SI     | _SP      | _DS     |
| _AX      | _BX    | _CX     | _DX       | _ES    | _AH    | _BH     | _CH      | _DH     |
| _SS      | _AL    | _BL     | _CL       | _DL    |
|----------+--------+---------+-----------+--------|

C programlama dili tarafından ayrılmış isimler.

- Değişken isimleri içinde *a-z* ve *A-Z* arası *İngilizce harfler*, 0-9
  arası *rakamlar* ve özel karakter olarak yalnızca "_" kullanılabilir. Diğer
  özel karakterler ve Türkçe karakterler (üÜçÇğĞıİöÖşŞ) kullanılamaz.

- Değişken isimlerinde rakamlar kullanılabilse dahi isimler *rakamlarla*
  *başlayamaz*

- Değişken isimleri teorik olarak istenilen uzunlukta olabilir fakat C
  derleyicisi için ilk *32 karakter* belirleyicidir. Yani ilk 32 karakter aynı
  ise sonrakiler farklı olsa da derleyici tarafından aynı isim olarak
  değerlendirilirler.

Bu kurallar, değişken isimleri için uyulması gereken teknik kurallardır.
Bunlara ek olarak program alışkanlıkları açısından da uyulması gereken
kurallar vardır.

- Değişkenlere verilen isimler kolay hatırlanır ve anlaşılır olmalıdır.
- İsimlendirmenin çok uzun veya kısa olmamasına dikkat edilir. 11-12
  karakterlik değişken isimleri ideal kabul edilir.
- İki kelimeden oluşan değişken isimlerinde kelimeler arasına "_"
  konulabileceği gibi ikici kelimenin baş harfi büyük yazılarak da kelimeler
  birbirinden ayrılabilir.
- Tamamı büyük harften oluşan değişken isimleri tercih edilmez, yaygın olarak
  sabitler için kullanılır. Değişkenlerin isimlerinin küçük harfli olması
  tercih edilir.

*** Veri Türleri:
C programlama dilinde 4 temel veri türü vardır; *char*, *float*, *int* ve
*double*

- *char*: Bir harf, bir sayı veya özel bir karakteri saklayabilirler. *char*
  tipindeki değerler _tek tırnak_ karakterleri arasında yazılmalıdır.
  Aktarılan karakterler bellekte karakterin kendisi olarak değil ASCII
  karşılığındaki sayı olarak tutulurlar. Bu sayede bu veriler toplama çıkarma
  gibi işlemlerde kullanılabilirler. Örneğin m = 'a' ise m değişkeni bellekte
  ASCII karşılığı yani 97 olarak tutulur. Eğer programda *m = m + 1*
  kullanılırsa artık m değişkeni 97 değil 98 olur yani artık *'b'* verisini
  tutmaktadır.
- *int*: -32768 ile 32767 (DOS işletim sistemlerinde) arasındaki *tamsayı*
  değerleri saklamak için kullanılır. C'de işaretsiz yazılan sayılar
  pozitiftir.
- *float*: Ondalıklı verilen sayıları ifade etmek için kullanılan değerleri
  tanımlar.
- *double*: Ondalıklı verilen çok küçük ve çok büyük değerleri tanımlamak
  için kullanılır. float türünden iki kat daha duyarlıdır.

*** Değişkenlerin tanımlama yerleri, şekilleri ve tanımlanması:
Standart C dilinde değişkenler üç ayrı yerde tanımlanabilir: *Fonksiyonların*
*üstünde*, *bloklar başlar başlamaz* (bloktan kasıt {} arası) ve
*fonksiyonlarda parametre olarak*. Fonksiyonlarda parametre olarak değişken
atanması başka bir konu. Blokların veya programın başında değişken
tanımlanması bir zorunluluk olmamasına karşın programlama pratiği açısından
oldukça kritiktir ve özellikle de C programlamada her zaman takip edilen bir
kuraldır. Ayrıca okunabilirliği arttırmak için her zaman değişken
tanımlandıktan sonra bir boş satır bırakılır.

Değişkenler tanımlanırken önce değişkenin *veri türü* sonra da değişkenin
*ismi* yazılır. Eğer ilk atama tanımlandığı yerde yapılacaksa atama işareti
olan "=" kullanılarak tanımlandığı gibi de atama yapılabilir.
#+BEGIN_SRC c
// Türü  Değişken Adı
long int ogrenciSayisi;
ogrenciSayisi = 32;
//veya eğer tanımlandığı yerde atama yapılacaksa
double cezaKatsayisi = 5.05;
#+END_SRC

Aynı türdeki değişkenler tek bir satırda tanımlanabilir.
#+BEGIN_SRC c
int gun, ay, yil;
#+END_SRC

*main* fonksiyonundan önce tanımlanan değişkenler, eğer ilk değer
verilmemişse sayısal veriler için sıfır, diğer veriler için boş olarak
atanır. Fonksiyon içersinde tanımlanan değişkenler ise ilk değerleri
verilmediğinde bellekte tanımlandıkları yerdeki rastgele değer olarak
atanırlar. Değişkenin kullanım amacına göre bu konuya dikkat edilmelidir.

* Genel girdi-çıktı (input-output) fonksiyonları
Veriler bir değişkene atılarak verilebileceği gibi bir *girdi aygıtı*
kullanılarak da (klavye, mouse vb.) verilebilir. Bu işleme /girdi/
/operasyonu/ denir. Hesaplanan sonuçları ve/veya bellekte tutulan değerleri
kullanıcıya gösterme işlemine ise /çıktı operasyonu/ denilmektedir.

Yaygın olarak kullanılan giriş-çıkış fonksiyonları, C standart giriş-çıkış
kütüphanesinde bulunur ve *stdio.h* (standart input-output) header dosyası
ile derleyiciye *#include* önişlemci direktifi ile bildirilir.

#+BEGIN_SRC c
#include <stdio.h>
#+END_SRC

** /printf/ Fonksiyonu:
Değişkenlerin değerlerini, hesaplanan sonuçları veya istenen mesajları ekrana
yazdırmak için kullanılır.

Syntax:
: printf("Çıktı metin (string) formatı", değişkenlerin listesi)
veya değişken kullanılmayacaksa:
: printf("String formatı")
şeklindedir.

Değişkenlerin kullanılması pythondan farklıdır. Pythonda stringler kendileri
veri türüdür ve içersinde değişkenlerin kullanılması için formatlanması
gerekir. Öte yandan C'de stringler hali hazırda bir metin formatıdır ve *yer*
*tutucular* yardımı ile formatlanırlar. Yer tutucular "%" ile başlarlar.
Syntax'ları aşağıdaki gibidir:

: %[önek][genişlik][.duyarlılık]<format karakteri>

|------------------+--------------------------------------------------------------------------|
| Format Karakteri | Anlamı                                                                   |
|------------------+--------------------------------------------------------------------------|
| d, i             | Tamsayı değişkenler (Onluk sistemde)                                     |
| ld               | Uzun tamsayılar için                                                     |
| lx               | Uzun tamsayılar (16'lık hex sistemde)                                    |
| o                | İşaretsiz tamsayı değişkenler için (sekizlik sistemde)                   |
| x                | İşaretsiz tamsayı değişkenler için (hex sisteminde)                      |
| X                | İşaretsiz tamsayı değişkenler için (hex sisteminde, büyük harfle)        |
| u                | İşaretsiz tamsayılar için                                                |
| c                | Char tipindeki değişkenler için                                          |
| s                | Metin (string)                                                           |
| f                | float ve double değişkenler için                                         |
| E,e              | float ve double değişkenlerin üstel gösterimi için                       |
|------------------+--------------------------------------------------------------------------|
|------------------+--------------------------------------------------------------------------|
| Önek Karakteri   | Anlamı                                                                   |
|------------------+--------------------------------------------------------------------------|
| +                | Pozitif olanlar başında "+" ile yazdırılır.                              |
| -                | Sayı genişliği büyük verilmişse sola dayalı yazar.                       |
| 0                | Sayı genişliği büyük verilmişse soldaki boşlukları sıfırlar ile doldurur |
|------------------+--------------------------------------------------------------------------|

- Genişlik sayının ne kadarlık karakter alanına yazılacağını belirler.
  /double/ ve /float/ tipindeki değişkenlerde *genişlik.duyarlılık* şeklinde,
  virgülden sonra kaç basamak uzunluğunda yazılacağı belirtilir. Stringlerde
  "/" karakteri *escape karakter*idir ve bundan sonrasında gelen karakter
  kaçış serisini ifade eder:

|--------------+------------------------------------|
| Kaçış serisi | Anlamı                             |
|--------------+------------------------------------|
| \n           | İmleç sonraki satır başında durur. |
| \t           | İmleç sonraki tab stop'ta durur.   |
| \a           | Alarm (beep sesi).                 |
| \\           | Backslach yazdırmak için.          |
| \"           | Tırnak işareti yazdırmak için.     |
|--------------+------------------------------------|

Örnek bir kaç program görelim:
#+BEGIN_SRC c
#include <stdio.h>

int main()
{
    int yas = 25;
    float oran = 0.18;
    char cinsiyet = 'E';

    printf("\n") // Boş bir satır yazdırır.
    printf("Cinsiyetiniz: %c\tYaşınız: %d\n", cinsiyet, yas)
    printf("Güncel \"KDV\" oranı %+.4f", oran)
}
#+END_SRC

** /scanf/ fonksiyonu:
Değişkenlerin içine klavyeden değer atamak için kullanılır. Syntax'ı
aşağıdaki gibidir:

: scanf("String formatı", değişkenin listesi)

İlk argüman printf fonksiyonundaki gibi string formatıdır. Değişken
listesinde dışarıdan girilecek değişkenler başında "&" işareti ile
yazılırlar. Bu işarete *adres operatörü* denir. Her bellek hücresinin bir
adresi vardır ve & işareti, peşine yazılan değişkenin bellek adresini üretir,
dışarıdan girilen değerin adresi verilen bellek hücresine aktarılmasını
sağlar. Değer girdisinin sonlandırılması için /Enter/ tuşuna basılır ve bu
andan itibaren değerde dışarıdan müdahale ile değişiklik yapılamaz. Yan yana
girilen değerlerde (aşağıdaki örnekte olduğu gibi) boşluk veya tab tuşları da
sonraki değişkene geçmemizi sağlar. *scanf* içersinde stringlerle girdi
mesajı yazıldığında hata alındığından bilgi mesajları *printf* ile yazılır.

#+BEGIN_SRC c
#include <stdio.h>
int main()
{
    int yas, agirlik;
    scanf("%d%f", &yas, &agirlik);
}
#+END_SRC

* Akış kontrol yapıları
Normal şartlar altında programlar ilk satırdan son satıra doğru diğer bir
deyişle yukarıdan aşağıya doğru ilerler. Elbetteki programlarımızda
kurduğumuz her mantığı bu kurala uydurmamız mümkün değil. Bu amaçla programın
veya fonksiyonun çalışma akışını konrol eden mekanizmalara *kontrol yapıları*
denir. C dilinde *sıralı*, *seçimli* ve *tekrarlı* olmak üzere 3 çeşit
kontrol yapısı mevcuttur. Şu ana kadar gördüğümüz örnekler sıralı yapılara
örnektir.

** /if/ anahtar kelimesi:
Verilen durum ya da koşulun *doğru* veya *yanlış* olmasına göre istenilen
işlem veya işlemleri gerçekleştirmek için kullanılan *seçimli* kontrol
yapılarıdır.
Syntax'ı şu şekildedir:

: if(koşul)
:     komut;

Bu yapıda *if* komutundan sonra gelen koşul doğru ise koşuldan sonra komut
çalışır. Eğer birden fazla komut çalıştırılacaksa bir blok içinde
yazılmalıdır. Esasında tek komut da olsa blok içersinde yazmak okunabilirlik
açısından daha iyidir.

: if(koşul){
:     komut1;
:     komut2;
:     ...   ;
:     ...   ;
:     komutN;
: }

Örneğin:
#+BEGIN_SRC c
if(yas > 18){
    printf("Yasiniz 18'den buyuk umarım basiniz goge ermistir.");
}
#+END_SRC

Eğer koşulun yanlış olması durumunda bir alternatif blok çalıştırılmak
isteniyorsa *else* komutu kullanılır:

: if(koşul){
:     komut1;
:     komut2;
:     komut3;
: }
: else{
:     komut4;
:     komut5;
:     komut6;
: }

Örneğin:
#+BEGIN_SRC c
if(yas > 18){
    printf("Yasiniz 18'den buyuk umarım basiniz goge ermistir.");
}
else{
    printf("Yasiniz 18'den büyük degil tuh...");
}
#+END_SRC

Eğer bir doğru veya değil durumundan ziyade, birkaç farklı koşula bağlı bir
program yazıyorsak sırayla bir kaç tane *if* kullanabiliriz fakat bu bize çok
temiz bir kod sunmaz. Mesela aynı değişkenin farklı koşullarında bu çok da
iyi bir kullanım değildir. Bu amaçla else ve if'i bir arada kullanabiliriz:

: if(koşul1){
:     komut1;
:     komut2;
: }
: else if(koşul2){
:     komut3;
:     komut4;
: }
: else{
:     komut5;
: }

Sadece *if*ler kullanarak bu ifadeyi yazdığımızda program çalışırken bütün
ifadeler okunacaktır fakat bu durumda koşullardan biri sağlandığında program
kalanını okumayı bırakır.

Örneğin:

#+BEGIN_SRC c
if(yas > 18){
    printf("Yasiniz 18'den buyuk umarım basiniz goge ermistir.");
}
else if(yas == 18){
    printf("Ooo buyumussun kiral.")
}
else{
    printf("Yasiniz 18'den kucuk tuh...");
}
#+END_SRC

** Üçlü şart operatörü (?:):
Bu operatör, üç adet operand alır. Esasında *if(koşul){}; else{}* yerine
kullanılır. Operatörün kendisi, iki komponentten yani "?" ve ":"
kısımlarından oluşur. "?" önündeki operandın sonucu doğru yani 0'dan farklı
ise "?" ve ":" arasındaki operand çalışır. Aksi takdirde ":" sağındaki
operand çalışır. Syntax'ı şöyle özetlenebilir:

:    |---doğru---|
:    |           ▼ 
: operand1 ? operand2 : operand3 ;
:    |                      ▲ 
:    |--------yanlış--------|

Örnek vermek gerekirse 60 ortalama geçer not iken öğrenci geçti mi kaldı mı
algoritması iki şekilde yazılabilir:
#+BEGIN_SRC c
ortalama >= 60 ? printf("Tebrikler! Gectiniz.") : printf("Seneye gorusuruz canim..");
#+END_SRC
veya
#+BEGIN_SRC c
if(ortalama >= 60)
    printf("Tebrikler! Gectiniz.");
else
    printf("Seneye gorusuruz canim..");
#+END_SRC

Görülebileceği gibi üçlü şart operatörü çok daha temiz bir kod yazmamızı
sağlar.

** /switch/ çoklu seçim anahtar kelimesi:
*switch* anahtar kelimesi, verilen ifadenin değerine göre verilen komut veya
komutları çalıştırır. Verilen ifadenin değerlerinin *ordinal (sıralı giden)*
olması gerekir. Bu ifadede kullanılacak veri tipleri *int* ve *char* olabilir
fakat float, double gibi ondalık değerler kullanılamaz. İfadenin aranan
değerleri, *case* anahtar kelimesiyle belirtilir. Syntax'ı şu şekildedir:

: switch(ifade){
:     case <değer1>:
:         komut1;
:         [break;]
:     ...
:     ...
:     ...
:     case <değern>:
:        komutN;
:        [break;]
:     [default: komutN;]
: }

Mesela 1'den 5'e kadar verilen bir sayının okunuşunu yazdıran bir programda
swtich komutunun kullanımı şu şekildedir:

#+BEGIN_SRC c
// Yanlış kullanım
switch(sayi){
    case 1:
        printf("Bir");
    case 2:
        printf("İki");
    case 3:
        printf("Üç");
    case 4:
        printf("Dört");
    case 5:
        printf("Beş");
    default: printf("Yanlış bir değer girdiniz.");
}
#+END_SRC

Eğer *break* anahtar kelimesi kullanılmazsa, program uygun durumu bulduktan
sonra da sonraki *case*'leri yani durumları kontrol etmeye devam eder. Yani
bu programa "3" girdisi verildiğinde çıktı şöyle olur:

: 1'le 5 arasında bir sayı giriniz: 3
: ----------------------
: Üç Dört Beş Yanlış bir değer girdiniz

*break* anahtar kelimesi okunduğunda, *switch* bloğu sonlanır sonraki
istenmeyen satırlar çalışmaz. Programın istenen çıktıyı vermesi için şu
şekilde yazılması gerekir.

#+BEGIN_SRC c
// Doğru kullanım
switch(sayi){
    case 1:
        printf("Bir");
        break;
    case 2:
        printf("İki");
        break;
    case 3:
        printf("Üç");
        break;
    case 4:
        printf("Dört");
        break;
    case 5:
        printf("Beş");
        break;
    default: printf("Yanlış bir değer girdiniz.");
}
#+END_SRC

Bu durumda alınan çıktı şöyle olur:

: 1'le 5 arasında bir sayı giriniz: 3
: ----------------------
: Üç

Her durumda *break* anahtar kelimesini kullanmak istemeyiz. Mesela iki
değerin sonucu olarak bir komut çalıştırmak istiyorsak alt alta iki *case*
ifadesi yazarız ve ilk boş *case*'imizden sonra *break* ifadesi kullanmayız.
Mesela cinsiyete göre vücut kitle endeksi hesaplayan bir programda hem 'K'
hem de 'k' için aynı komutu kullanırız:

#+BEGIN_SRC c
switch(cinsiyet){
    case 'k':
    case 'K':
        /* Komutlar */;
        break;
    case 'e':
    case 'E':
        /* Komutlar */;
        break;
    default: 
        /* Komutlar */;
}
#+END_SRC

* Döngüler (Loop'lar)

Döngüler, program akışını kontrol etmenin bir başka yoludur. Belirli bir
mantığı içeren program adımlarının tekrarlanması olarak özetlenebilirler.

** /goto/ ile sayaç (counter) kontrollü döngüler:

Yapılacak tekrar miktarının bilindiği durumlarda döngüler bir sayaç
kullanarak tasarlanabilir. Sayaç, döngünün kaç defa tekrarlandığını tutan bir
değişkendir. Döngünün her adımda sayaç arttırılır veya azaltılır. Döngünün
sonunda, sayacın istenilen değere gelip gelmediği kontrol edilerek döngü
sınırlanır.

Sayaç kontrollü döngüleri oluşturmanın en ilkel yolu (tabir yanlış olabilir
ama yöntem gerçekten de eski) *goto* anahtar kelimesi ve başlıklar
kullanılmasıdır. Syntax şu şekildedir:

: int sayac;
: sayac = <baslangic degeri>;
: 
: BASLA:
:     <komut1>;
:     <komut2>;
:     ...
:     ...
:     <komutn>;
:     sayac = sayac <+ veya -> <adım miktarı>
:     if(sayac <karşılaştırma operatörü> <bitiş değeri>)
:         goto BASLA

Örnek bir kullanım görelim. Mesela 100 defa "Merhaba Dunya!" yazdırmak için:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
	int sayac = 1;
DONGU:
	printf("Merhaba Dunya!\n");
	sayac++;
	if (sayac <= 100)
		goto DONGU;
	return 0;
}
#+END_SRC

Görülebileceği gibi *goto* kullanımı pek de pratik değil. Programın mantığı
açısından bir sıkıntı yok ama diğer metodlara göre ekstra kod yazmamız
gerekiyor döngünün kendisi *if* ile koşullanmış bir ifadeye bağlı (ki C
programlama dilinde if ile koşullanan ifadelerin zaman zaman programları
yavaşlattığı bilinmektedir).

** /while/ döngüleri:

*while* anahtar kelimesi kendisini oldukça açıklar nitelikte. Verilen bir
*koşul/durum doğru olduğu sürece* bir takım komutların yürütülmesini sağlar.
Syntax'ı şu şekildedir:

: while(koşul | durum){
:     komut1;
:     ...
:     ...
:     komutN;
: }

Eğer koşul veya durum hiçbir zaman yanlış (veya 0) olmazsa program akışı
döngünün dışına çıkamaz ve RAM dolana kadar döngü içersindeki komutlar
sürekli tekrar ederek bir /sonsuz döngü (infinite loop)/ oluşturur. Mesela
yukarda *goto* ile yazılan kodu bir de *while* ile yazalım:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int sayac = 1;
    while(sayac <= 100){
        printf("Merhaba Dünya!\n");
        sayac++;
    }
    return 0;
}
#+END_SRC

Yalnızca satır sayısına baktığımızda bir satır kazandığımızı düşünebiliriz
fakat kodun okunabilirliği, *while* döngüsünde çok daha iyidir.

** Gözcü kontrollü (sentinel controlled) döngüler:

Çalıştırılması gereken adımların tekrar sayısı belli olmadığında döngüyü
tekrar sayısına değil bir "gözcü değer"e bağlarız. Program kullanıcının
dışarıdan belli bir değer veya değer grubundan birinin girdi olarak verilmesi
veya program içersinde belli bir değerin oluşmasına göre sonlandırılır.
Mesela klavyeden "-1" değeri girilinceye kadar alınan sayıların ortalamasını
hesaplayan bir program şöyle yazılabilir:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    long toplam = 0;
    int sayi, adet = 0;
    float ortalama;
    printf("Sayi giriniz (Sonlandirmak icin -1): ");
    scanf("%d", &sayi);
    while(sayi != -1){
        toplam += sayi;
        adet++;
        printf("Sayi giriniz (Sonlandirmak icin -1): ");
        scanf("%d", &sayi);
    }
    ortalama = toplam / adet;
    printf("----------------\n");
    printf("Verilen tum sayilarin ortalamasi: %.2f\n", ortalama);
    return 0;
}
#+END_SRC

** /for/ döngüleri:
*for* döngüleri, özellikle de tekrar edilen işlem sayısının belli olduğu
durumlarda kullanılan başka bir yapıdır. Sayaç kontrollü döngülerde
kullanımı, *while* döngülerinden daha kısa ve çoğu zaman daha uygundur.
Syntax'ı aşağıdaki gibidir:

: for(DöngüDeğişkeni = ilkDeğer; DöngüKoşulu; AdımMiktarı){
:     komut1;
:     komut2;
:     ...
:     komutN;
: }

*for* döngüleri görülebileceği gibi 3 bileşenle tanımlanır. Döngü değişkenine
ilk değerinin atanması yalnızca *for* komutunun ilk defa okunmasında çalışır.
/Döngü koşulu/, her seferinde *döngüye girmeden önce* kontrol edilir ve eğer
doğru ise veya 0'dan farklı ise döngüye devam edilir. Döngü her sonlandığında
/adım miktarı/ kısmı çalışır ve görevi, döngü değişkenini güncellemektir.
Mesela i döngü değişkeni için *i++*, *i--* veya *i += N* gibi kullanılabilir.
Bir *for* ifadesi, her zaman *while* ifadesi olarak yazılabilir:

: DöngüDeğişkeni = ilkDeğer;
: while(DöngüKoşulu){
:     komut | komutlar;
:     AdımMiktarı;
: }

Çok güzel bir for döngüsü örneği, bir sayının asallığının kontrolüdür (neden
bilmiyorum ben bu programı çok seviyorum). Programı yazıp bir bakalım:
#+BEGIN_SRC c
#include <stdio.h>
int main(){
    long sayi;
    int test = 1; // default varsayim, sayinin asal oldugu.
    long i; // dongu degiskenimiz.
    printf("Bir sayi giriniz: ");
    scanf("%d", &sayi);
    printf("-----------------\n");
    if(sayi == 1)
        test = 0;
    else{
        for(i = sayi -1; i > 1 && test == 1; i--){
            if(sayi % i == 0)
    		    test = 0;
    	}
    }
    if(test)
    	printf("Yazdığınız sayi asaldir.\n");
    else
    	printf("Yazdiginiz sayi asal degildir.\n");
    return 0;
}
#+END_SRC

** /do-while/ döngüsü:
*while* döngülerine benzer yapıda olan *do-while* döngüleri, önce komutları
alır daha sonra /döngü koşulunu/ kontrol eder. Yani döngü başlamadan önce,
döngü gövdesindeki komutlar bir defa çalışır, ardından *while* döngüsü gibi
çalışmaya devam eder. Syntaxı şu şekildedir:

: do{
:     komut1;
:     ...
:     komutN;
: }while(koşul | durum);

Her *do-while* döngüsü, aşağıdaki gibi bir *while* döngüsü olarak
yazılabilir:

: komut | komutlar;
: while(koşul | durum){
:     komut | komutlar;
: }

Tüm bu farklı döngüler, birbirleri şeklinde yazılabilir ve birbirlerine
benzer işleri yapabilir. Aralarında özellikle iş akışı ve algoritmanın oluşma
şekli açısından ufak farklar vardır fakat hangisinin nasıl ve nerede
kullanılacağı çoğunlukla programlama alışkanlığı ile ilgilidir. Mesela
zorlarsak *for* döngülerini de *while* döngüleri gibi /gözcü kontrollü/ hale
getirebiliriz fakat hem pratik değildir hem de kodun okunabilirliği azalır
veya döngü başlamadan önce komutların bir kez çalışmasını istiyorsak bunu
*while* döngüsüyle yapmanın anlamı yoktur, basitçe *do-while* döngülerinden
faydalanabiliriz. Bunlar göz önünde bulundurularak programcının hangi
döngünün uygun olduğuna karar vermesi daha doğrudur.

Mesela döngü seçimine bir örnek olarak yukarıda oluşturduğumuz /ortalama/
/hesaplama/ uygulamasını gösterebiliriz. Burada *printf* ve *scanf*
satırlarını iki defa kullanmak yerine şunu yapabiliriz:
#+BEGIN_SRC c
do{
    printf("Sayi giriniz (Sonlandirmak icin -1): ");
    scanf("%lf", &sayi);
    if(sayi != -1){
        toplam += sayi;
        adet++;
    }
}while(sayi != -1);
#+END_SRC

** İç içe (nested) döngüler:

İki döngünün birlikte kullanıldığı fakat bu birlikte kullanım ilişkisinin
birbirine bağlı olduğu döngülerdir. Dıştaki döngünün her adımında, içteki
döngü adım adım çalışır. Başka bir deyişle içteki döngü her sonlandığında
dıştaki döngü bir adım daha çalışır ve içteki döngü baştan döner.

Örneğin aşağıdaki döngüyü inceleyecelim:
#+BEGIN_SRC c
n = 0;
for(i = 1; j <= 4; i++)
    for(j = 1; j <= 3; j++)
        n = n + 1;
#+END_SRC

Yukarıdaki örnekte içteki döngü 3 defa çalışır. Dıştaki döngü de içteki
döngüyü 4 defa çalıştırır. Dolayısıyla döngü toplamda 12 defa çalışacağından
sonuçta *n* değişkeni *12 defa 1 ile toplanır* ve son değeri 12 olur.

|---+---|
| i | j |
|---+---|
| 1 | 1 |
|   | 2 |
|   | 3 |
|---+---|
| 2 | 1 |
|   | 2 |
|   | 3 |
|---+---|
| 3 | 1 |
|   | 2 |
|   | 3 |
|---+---|
| 4 | 1 |
|   | 2 |
|   | 3 |
|---+---|

Tabloda da adımların nasıl tekrar edildiği ve neden toplam 12 adım olduğu
görülmektedir. İç içe döngülerin kullanımında syntaxa oldukça dikkat
edilmelidir. Mesela aşağıdaki kod satırı bir iç içe döngü belirtmez:

#+BEGIN_SRC c
for(i = 1; j <= 4; i++);
    for(j = 1; j <= 3; j++)
#+END_SRC

İlk *for* ifadesinin sonundaki ";" sonraki döngünün, bu döngü altında
işlenmesini engeller. Doğal olarak da döngüler iç içe değildir ve istenilen
sonuç elde edilemez.

** /break/ deyimi:

*break* deyimi, daha önce *switch-case* yapısına benzer şekilde döngülerde de
kullanılır. Döngü içersinde *break* komutunun amacı, çalıştığı yerde döngüyü
sonlandırarak program akışını döngü dışına yönlendirmektir. Bu noktada
program akışı döngü dışındaki ilk satırdan devam eder. Örnek olarak aşağıdaki
programı inceleyelim:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int i;
    for(i = 0; i <= 5; i++){
        if(i == 3)
            break;
        printf("i = %d\n", i);
    }
    return 0;
}
#+END_SRC

Mesela burada döngüyü i'nin 5 veya daha küçük değerleri ile oluşturmuş olsak
da i = 3 olduğunda *if* koşulu sağlanır ve *break* komutu çalışarak /bir üst/
/seviyedeki/ döngüyü sonlandırır. Bu programın çıktısı şu şekilde olur:

: i = 0
: i = 1
: i = 2

** /continue/ deyimi:

*break* deyimine benzer şekilde döngüleri şartlandırmak için kullanılır fakat
*continue* deyimi döngüyü bitirmek yerine çalıştığı yerde bir üst seviyedeki
döngünün /sonraki adımına geçer/. Örnek üzerinden incelemek gerekirse:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int i;
    for(i = 0; i <= 5; i++){
        if(i == 3)
            continue;
        printf("i = %d\n", i);
    }
    return 0;
}
#+END_SRC

Bu program çalıştığında i = 3 olduğunda bu sefer *continue* komutu çalışır ve
program döngünün bir sonraki adımına geçer yani i = 3 için *printf*
fonksiyonu *çalışmaz*. Çıktı aşağıdaki gibi olur:

: i = 0
: i = 1
: i = 2
: i = 4
: i = 5

* Fonksiyonlar

Bu noktaya kadar kullandığımız konseptler (döngüler, değişkenler vs.)
programlamanın temel ögelerinden olsalar da tek başlarına karmaşık bir
problemi çözmede yetersiz kalmaktadırlar. Fonksiyonları kullanmanın iki
önemli amacı vardır. Bunlardan biri, program mantığını farklı bölümlere
ayırarak uzun kaynak kodlarına sahip programların daha kolay
değiştirilebilmesini, özelleştirilebilmesini, tamir edilebilmesini sağlamak,
mantığı daha okunabilir hale getirmektir. Fonksiyonların bir diğer faydası da
devamlı tekrar eden /mantık/ları yalnız bir defa yazarak programın farklı
yerlerinde kullanabilmemizi sağlamasıdır. Mesela /donguler/ klasorunda
/sacma_bi_program.c/ kodunu inceleyecek olursak üs almak icin kullandığımız
mantığı 4 defa kullandığımızı görürüz. Halbuki bunu tek bir defa /us_alma/
*fonksiyonu* şeklinde yazıp 4 defa kullanmak programı daha okunabilir kılar
ve kısaltır.

Fonksiyonların çalıştırılması işine /çağırma/ denir. Her fonksiyon *ismi*
ve kendisinden istenen işi gerçekleştirmek için ihtiyaç duyduğu değerler yani
*parametler* veya *argümanlar* ile çağırılırlar. Fonksiyonlar kendilerine
verilen argümanlarla beraber yaptıkları işlerin sonuçlarını, kendilerini
çağıran fonksiyona bildirirler ve bu değere *return value* denir.

Örneğin sqrt fonksiyonu bir sayının karekökünü alır.

: a = sqrt(x);

şeklinde fonksiyon çağırıldığında, fonksiyon ismi /sqrt/, argüman(lar) /x/,
reutn değeri ise /a değişkenine atanan değer/dir.

C dilinde yönetici fonksiyon *main()* fonksiyonudur ve program çalışmaya
*main()* fonksiyonundan başlar. *main()* fonksiyonu diğer fonksiyonları
çağırarak çalıştırır. Örnek bir fonksiyon hiyerarşisi şöyle olabilir:

:             main()
:             / | \
:      |-----|  |  |-----|
:      |        |        |
:    func1()  func2()  func3()
:     /  \
: |--|    |--|
: |          |
: func4()    func5()

** Standart fonksiyonlar

Bu fonksiyonlar C dili geliştiricileri tarafından programcının kullanımı
için yazılmış hazır fonksiyonlardır. Teknik olarak C dilinin parçası
değillerdir fakat C dili için standardize edilmişlerdir. Bunların
/prototip/leri header dosyalarında bulunur ve kullanılmak istendiğinde
*include* önişlemci direktifi ile bildirilerek kullanılabilirler.

*** 1- Math kütüphanesi (/math.h/):

Bu kütüphane içersinde matematiksel işlemleri gerçekleştirmek için kullanılan
fonksiyonlar mevcuttur. Söz konusu fonksiyonlar *double* türünde argümanlar
alır ve yine *double* türünde değerler return eder. *#include <math.h>*
direktifiyle programa dahil edilebilirler. Sık kullanılan *math*
fonksiyonları şöyle sıralanabilir:

|------------+------------------------------------------------------------------------------------------|
| Fonksiyon  | Açıklama                                                                                 |
|------------+------------------------------------------------------------------------------------------|
| sqrt(x)    | x'in karekökünü alır.                                                                    |
| exp(x)     | Euler sabiti'nin (e) x dereceden kuvvetini return eder (e^x).                            |
| log(x)     | x'in doğal (e tabanında) logaritmasını alır.                                             |
| log10(x)   | 10 tabanında x'in logaritmasını return eder.                                             |
| fabs(x)    | x'in mutlak değeri                                                                       |
| ceil(x)    | x'i kendisinden büyük en küçük tam sayıya yuvarlar (ceil(-9.8) = -9.0; ceil(9.8) = 10.0) |
| floor(x)   | x'i kendisinden küçük en büyük tam sayıya yuvarlar (ceil'in tersi bi manada)             |
| pow(x, y)  | x'in y dereceden kuvveti yani x ^ y                                                      |
| fmod(x, y) | x/y işleminin kalanını verir. Bi yerde x % ile aynıdır.                                  |
| sin(x)*    | x'in sinüsü                                                                              |
| cos(x)*    | x'in kosinüsü                                                                            |
| tan(x)*    | x'in tanjantı                                                                            |
|------------+------------------------------------------------------------------------------------------|

: *: sin, cos ve tan fonksiyonları radyan cinsinden değer alır. Derece cinsinden bir değeri radyana çevirmek
: için math kütüphanesinde bulunan bir sabit olan M_PI ile çarpmamız gerekir. Örneğin "alpha"yı radyana çevirmek
: için (alpha * M_PI / 180) işlemini yapmamız gerekir (M_PI aslında pi sayısı.)

*** 2- Standart kütüphane (/stdlib.h/):

Bellek yerleştirmeleri, rastgelelik fonksiyonları, tür dönüşümleri
fonksiyonlarının yanı sıra bunlara yardımcı fonksiyonları yani standart
işlemleri içeren kütüphanedir. *stdlib.h* header dosyası ile çağrılır.

**** /rand()/ fonksiyonu:

0 ile *stdlib* içersinde tanımlı olan *RAND_MAX* sabiti (Windows ve DOS'ta
32767, Unix ve Linux'ta 2147483647) arasında rastgele bir sayı üretir. Bu
sayıyı belli bir başlangıç değeri üzerinde bir dizi aritmetik operasyon
kullanarak üretmek de mümkündür:

#+BEGIN_SRC c
rastgele = rand(); /* 0 ile RAND_MAX arasinda rastgele bir sayi */
zarDegeri = 1 + rand() % 6; /* 1 ile 6 arasında rastgele bir sayi */
baskaSayi = rand()10 + 14; /* 14 ile 23 arasinda rastgele sayi */
#+END_SRC

**** /srand()/ fonksiyonu:

*rand()* fonksiyonuna benzer şekilde ve benzer amaçla çalışır fakat farklı
olarak *srand()* bir argüman alır ki bu da rastgele sayı serisinin başlangıç
noktasını belirler. Burada amaç, her seferinde farklı bir seri sunmak ve
rastgeleliğin düzeyini artırmaktır. Argüman olarak kullanıcı girdisi de
verilebilir fakat pek iyi bir pratik değildir. Genellikle *time.h*
kütüphanesinde bulunan *time()* fonksiyonundan faydalanılır ki bu fonksiyona
argüman olarak /"NULL"/ verildiğinde 01-01-1970'ten bu yana geçen zamanın
saniye cinsinden ifadesini çıktı olarak verir. Böylece *srand()* her
çalıştığında farklı bir başlangıç noktası verilir. *srand()* kendisi bir
rastgele değer üretmez, *rand()* fonksiyonu ile birlikte kullanılır.

#+BEGIN_SRC c
srand(time(NULL))
rastgele = rand() % 49 + 1;
#+END_SRC

** Kullanıcı tanımlı fonksiyonlar:

C kütüphaneleri her zaman ihtiyaç duyduğumuz fonksiyonlara sahip olmayabilir.
Genellikle tüm programlama dillerinde kullanıcının yazdığı fonksiyonlar
programın temelini oluşturur. Genel olarak bir fonksiyonun yapısı şu şekilde
özetlenebilir:

: |--------[Fonksiyon Başlığı]------------------|
: [FonksiyonTürü] <FonksiyonAdı> ([Parametreler]){
:     ..............;-|
:     ..............; |----> Fonksiyon bloğu
:     ..............;-|
: }

**** Parametre ve return değeri olmayan fonksiyonlar:

Bu fonksiyonlar *ne bir parametre alır ne de bir return değeri verirler*.
/Return değerleri olmadığı için/ fonksiyon türü olarak *void* ifadesi
yazılır. /Fonksiyonun türü aynı zamanda return değerinin de türüdür/. Fakat
fonksiyon türü verilmediğinde çoğunlukla tahmin edildiği gibi return değeri
olmadığı varsayılmaz; return değerinin *int* türünde olduğu varsayılır.

İlk örneğimiz klasik Merhaba Dünya:

#+BEGIN_SRC c
// iki türlü tanımlanabilir:
void fonksiyon(void){
    printf("Merhaba Dünya");
}
// ya da:
void fonksiyon(){
    printf("Merhaba Dünya");
}
#+END_SRC

**** Parametre alıp return değeri olmayan fonksiyonlar:

Bu tür fonksiyonlar, çağıran fonksiyondan en az bir /parametre/ (/argüman/)
alırlar ve çoğunlukla bu parametreler üzerinde değişiklik yaparlar. Bu
fonksiyonlara verilen parametrelere /girdi parametresi/ denir. Girdi kabul
eden fonksiyonlarda fonksiyonun kabul ettiği değişkenler, veri türü ile
birlikte fonksiyon parantezi içersinde virgüllerle ayrılarak tanımlanır.
Bunları karşılayan değişkenler ise fonksiyon çağırılırken parantez içinde
yazılır.
#+BEGIN_SRC c
void fonksiyon(veriTürü değişken, veriTürü değişken){
    /* değişkenin kullanıldığı işlemler */
}
#+END_SRC

Ana fonksiyon içinde bu fonksiyonların çalıştırılması ise şu şekildedir:
#+BEGIN_SRC c
int main(){
    fonksiyon(gonderilenDeger)
}
#+END_SRC
Burada gönderilen değer, main içersinde tanımlanmış bir değişken olabileceği
gibi sabit bir obje de olabilir.

**** Parametre alıp return değeri olan fonksiyonlar:

Bu fonksiyonlar, çağıran fonksiyondan bir ya da birden fazla parametre alır
ve bunlar üzerinde çeşitli işlemler gerçekleştirerek geriye bir değer
döndürürler. Geriye değer döndürmek için *return* komutu kullanılır. Syntaxı
şu şekildedir:

: return [geriDönüşDeğeri];

*return* komutu çalıştığında fonksiyon sonlanır ve sonrasında yazılan kısım
çalışmaz. Return değeri, komut için opsiyoneldir ve geri dönüş değeri
vermeden mesela belli bir koşula bağlı olarak fonksiyonu sonlandırmak için de
return komutu kullanılabilir.

Değer geri veren bir fonksiyon örneği görelim:
#+BEGIN_SRC c
#include <stdio.h>
int topla(int a, int b){
    return a + b;
}
int main(){
    int a, b;
    printf("İki adet sayi giriniz: ");
    scanf("%d%d",&a,&b);
    printf("Girilen sayilarin toplami %d", topla(a, b));
    return 0;
}
#+END_SRC

**** Parametre akış türleri:
Fonksiyonlara değerler gönderilirken iki yol kullanılabilir. Bunların
detayları başka bir konu fakat genel olarak anlatalım:
- *Değerlerle çağırım (call by value)*: Bu yöntemde fonksiyona gönderilen
  değerler çağırılan fonksiyondaki parametrelerin içersine kopyalanır.
  Kopyalanan değerlerin değişmesi orikinal değerleri etkilemez. Varsayılan
  olarak (yani buraya kadar yazdıklarımız da bunlara dahil) fonksiyonlar bu
  şekilde çalışır.
- *Bağlantılı çağırım (call by referance)*: Bu yööntemde ise değerlerin
  kopyalandığı değişkenlerin değişmesi, orijinal değişkenin değerini de
  etkiler. Ayrıntılar daha sonra.

**** Fonksiyon prototipleri:
Derleyici programı yukarıdan aşağıya doğru okuduğu için kendi yazdığımız
fonksiyonları her zaman kullanmadan önce yani main fonskiyonundan önce
yazdık. Fakat main fonksiyonunda değişkenleri tanımladığımız gibi main
fonksiyonundan önce programın kendisine fonksiyonlarımızı tanıtarak
istediğimiz yerde kullanmamız da mümkün. Bunu yapmak için fonksiyonun return
değerinin türünü ve ismini (opsiyonel olarak beklediği parametreleri de)
*prototip* olarak /fonksiyonun örneklemlerinden (çağırımlarından)/ önce 
yazmamız gerek. Yukarıdaki örneğin bu syntaxta yazımı şöyle olur:
#+BEGIN_SRC c
#include <stdio.h>
int topla;
// argümanlar verilebilir de ama verilse dahi derleyici bunları okumaz
// kodun diğer programcılar tarafından okunabilirliği adına iyi bir pratiktir
int main(){
    int a, b;
    printf("İki adet sayi giriniz: ");
    scanf("%d%d",&a,&b);
    printf("Girilen sayilarin toplami %d", topla(a, b));
    return 0;
}
int topla(int a, int b){
    return a + b;
}
#+END_SRC

*** Depolama sınıfları:
Şimdiye kadar değişkenlerin temel nitelikleri anlatılmıştı. Değişkenlerin
temel nitelikleri /türü, ismi ve değeri/dir. Bu nitelikler bir değişken
tanımlamak için yeterli olsa da bunlara ek olarak değişkenlerin *depolama sınıfı*
(storage classes), *ömrü* (duration) ve *faaliyet alanı* (scope) nitelikleri
de vardır.

C dilinde değişkenlerin depolama sınıfı belileyicilerle tanımlanır ve 4
farklı tür depolama sınıfı vardır: *auto*, *register*, *static* ve *extern*.
Bu belirleyicilerle tanımlanan değişkenler, /ömür/lerine göre ikiye
ayrılırlar: *otomatik depolama sınıfları* (automatic storage classes) ve
*durağan depolama sınıfları* (static storage classes).

**** Otomatik depolama sınıfları (automatic storage classes):
Bu tür değişkenler *auto* veya *register* belirleyicileri ile tanımlanırlar.
Belirleyiciler, değişkenin değişken türü önüne yazılarak kullanılırlar. Bir
değişkenin /otomatik depolama ömrüne sahip olması/, tanımlandığı bloğun
çalışması durumunda belleğe yerleştirilip bloğun çalışması sonlandığında da
bellekten silinmesi silinmesi anlamına gelir. C dilinde yalnızca değişkenler
otomatik depolama ömürlüdürler, fonksiyonlar değil (?).

Bir fonksiyonun lokal değişkenleri, bir belirleyici yazılmadığında varsayılan
olarak otomatik depolama ömürlüdür. Otomatik depolama ömrü belirleyicisi
olarak çoğunlukla *auto* kullanılmaktadır. *auto*, değişkenleri ihtiyaç
olduğunda kullanıp değişkenin işi bittiğinde /tamamen/ ortadan kaldırarak
hafızayı verimli kullanmamızı sağlar. Syntax şu şekildedir:

#+BEGIN_SRC c
auto double a,b;
#+END_SRC

Öte yandan *register* da benzer şekilde çalışsa da veriyi tamamen yok etmez.
*register* ismi, CPU'lar üzerindeki register yani kaydedicilerden gelir.
Bunlar CPU içindeki bilgileri (çoğunlukla geçici olarak) depolayan çok düşük
kapasiteli belleklerdir. Çalıştırılmak üzere makine koduna çevrilen
programlar çalışırken, üzerinde hesaplama yapılacak veya basit işlemler
gerçeleştirilecek olan veriler bu kaydedicilere çağırılarak üzerlerinde işlem
yapılır. Kullandığımız değişkenlerin hafızadan silinse dahi kaydediciler
içersinde saklanmay devam etmesini istiyorsak *register* belirleyicisini
kullanırız. Fakat *register* her zaman bu amacı yerine getiremez; söz konusu
kaydediciler çok düşük kapasiteli olduğundan görece büyük programlardaki veri
akışı dolayısıyla "register" edilen yani kaydedilen veriler, yenilerini
depolamak üzere atılır. Fakat eğer veriler saklanabilirse programın devam
eden aşamalarında bu veriye tekrar erişmek daha hızlı olacaktır. Syntax şu
şekildedir:

#+BEGIN_SRC c
register int a,b;
#+END_SRC

Hem kullanım amacını etkin bir şekilde yerine getirememesi hem de modern
derleyicilerin verilerin nasıl depolanacağına etkin bir şekilde karar
verebilmesi sebebiyle *register* günümüz programlarında sık kullanılan bir
belirleyici değildir.

**** Durağan depolama sınıfları (static storage classes):
Bu tür /değişken/ ya da /fonksiyonlar/, *extern* veya *static*
belirleyicileri kullanılarak tanımlanırlar. Bir "tanımın" durağan depolama
ömrü olması denek, programın çalışmaya başlamayısyla birlikte hafızaya
alınması ve program bitinceye kadar hafızada kalması anlamına gelir. Global
değişken ve fonksiyonlar ile *static* belirleyicisi ile tanımlanmış olan
lokal değişkenler, durağan depolama sınıfındadır. Lokal değişkenlerden farklı
olarak global değişken ve fonksiyonlar varsayılan olarak *extern*
belirleyicisi ile tanımlıdırlar.

Tanımlamak gerekirse /global değişkenler/, fonksiyonların dışında tanımlanan
değişkenlerdir. Bir değişkenin global olması, program çalıştığı andan
itibaren bellekte tutulması anlamına gelir. Bu tür değişkenler ve
fonksiyonlar, programın her yerinde kullanılabilmektedir.

*static* belirleyicisi ile tanımlanmış olan lokal değişkenler, global
değişkenlerden farklı olarak yalnızca tanımlandıkları fonksiyon içersinde
kukllanılabilirler fakat otomatik değişkenler gibi fonksiyon sonlandığında
hafızadan silinmezler; fonksiyonun çalışmasıyla hafızaya alınır ve program
sonlanana kadar, sahip oldukları değerle birlikte hafızada tutulurlar.
Avantajları ise aynı fonksiyonun tekrar çalıştırılması durumunda ortaya
çıkar. *static* bir değişken tanımlanmış bir fonksiyon, program içersinde
tekrar çalıştırıldığındasöz konusu değişken en son sahip olduğu değerle
birlikte halen hafızadadır. Bu sayede fonksiyonun iki farklı çağırımı
arasında bir değeri taşıyabilmenin yanı sıra, *static* bir değişkenin tekrar
çağırımı da hali hazırda hafızada olduğu için daha hızlıdır. Tanımlama anında
değer ataması, yalnızca fonksiyon ilk çalıştığında okunur. Fonksiyon tekrar
çalıştığında, değişken tekrar tanımlanmaz bunun yerine en son sahip olduğu
değere sahiptir ve bu değerle çağırılır. Syntax şu şekildedir:
#+BEGIN_SRC c
static int a = 1;
#+END_SRC
*static* olarak tanımlanmış sayısal nitelikli değişkenlerin ilk değeri, eğer
tanımlanmamışsa her zaman sıfırfır.

*** Faaliyet alanı kuralları (scope rules):
Değişkenin geçerli olduğu (diğer bir deyişle kullanılabileceği) program
parçasına, o değişkenin /faaliyet alanı/ (/scope/) denir. Örnek vermek
gerekirse bir blok yani, {} arasında kalan program parçası, içersinde
tanımlanan yerel değişkenler yalnızca o blok ve o bloğun içersindeki /nested/
bloklarda geçerlidir. C programlarında üç farklı scope vardır; *Dosya*
*faaliyet alanı* (file scope), *blok faaliyet alanı* (block scope) ve
*fonskiyon faaliyet alanı* (function scope).

**** Dosya faaliyet alanı (file scope):
Bir tanımlama fonksiyonların dışında yapıldığında (bu fonksiyonlara *main*
fonksiyonu da dahil) dosya faaliyet alanına sahiptir. Bu scope'taki
tanımlamalar, tanımlandıkları noktadan itibaren dosyanın sonuna kadar tüm
fonksiyonlarda tanınır ve kullanılabilirler. Global değişkenler, fonksiyon
tanımlamaları ve fonksiyon prototipleri dosya faaliyet alanına sahip
tanımlamalardır.

**** Blok faaliyet alanı (block scope):
Herhangi bir blok içersindeki bütün bildiriler blok faaliyet alanına
sahiptir. Bunların faaliyet alanları, blok içersinde tanımlandıkları yerde
başlar ve blok sonunda "}" işaretinde sonlanır. İç içe (nested) bloklar
arasında bir faaliyet alanı hiyerarşisi söz konusudur. Dış blok içersindeki
değişkenler içteki bloklarda da tanımlıdır fakat iç blokta tanımlanmış
değişkenler dış bloklarda tanımlı değildir. Dış ve iç bloklardaki değişkenler
aynı isimlere sahip olabilir. Bu durumda iç bloktaki değişken dış bloktakini
maskeler ve yalnızca kendisinin kullanılmasına izin verir. 

**** Fonksiyon faaliyet alanı (function scope):
Fonksiyon faaliyet alanı, blok faailet alanına benzer. Fonksiyon parametresi
olarak ve fonksiyon gövdesi içersinde tanımlanan değişkenler yalnızca o
fonksiyon içersinde geçerlidir. *static* keywordü ile tanımlanan yerel
değişkenler her ne kadar programın sonuna kadar bellekte tutulsa da /blok/
faaliyet alanına sahiptirler. Faaliyet alanları ömürlerini, ömürleri de
faaliyet alanlarını değiştirmez.

Tüm faaliyet alanlarının örneklerini aşağıda görebiliriz:
#+BEGIN_SRC c
#include <stdio.h>
int x = 10; /* x değişkeni globaldir ve dosya faaliyet alanına sahiptir. */
void a(void);
void b(void);
void c(void);
int main(){
    int x = 20; /* bu x değişkeni ise lokal bir değişkendir. */
    printf("main blogundaki x = %d\n", x); /* buradan çıktı olarak 20 alınır.
    lokal bir değişken ile global bir değişken aynı isme sahipse, lokal 
    değişken global değişkeni maskeler. */
    { /* yeni bir blok başlattık. bu blok içersindeki her şey, blok faaliyet
         alanına sahiptir. */
        int x = 30;
        printf("main içersindeki blokta x = %d\n", x); /* burdan da yine iç
        bloktaki çıktı alınır. yani x = 30 çıkar. */
    } /* burada blok sonlanır. bundan sonraki faaliyet alanı, main
         fonksiyonuna aittir. */
    printf("bloktan sonra main fonksiyonundaki x = %d\n", x); /* artık blok
    alanından çıktık ve main fonksiyonunun alanına geri döndük. burada
    göreceğimiz x değeri 20 olur çünkü blok içersineki x değeri lokal olduğu
    ve blok faaliyet alanı ile sınırlı olduğu için main fonksiyonu içersinden
    bu değere ulaşılamaz. */
    printf("------Fonksiyonlar ilk defa çağırılıyor.------\n");
    a(); /* otomatik ömürlü, yerel bir x değişkeni var. */
    b(); /* durağan ömürlü, yerel bir x değişkeni var.  */
    c(); /* içersinde tanımlanmış bir x değişkeni yok, globaldeki x
    değişkenini kullanıyor. */
    printf("----Fonksiyonlar ikinci defa çağırılıyor.----\n");
    a(); /* yerel x'i yeniden oluşturuyor. (otomatik) */ 
    b(); /* yerel x'in son halini kullanıyor. (statik) */
    c(); /* global x'in eski değerini kullanıyor. */
    printf("main içersinde x'in son değeri = %d\n", x);
    return 0;
}
void a(void){
    auto int x = 40; /* fonksiyon her çağırıldığında bu değer atanır. */
    printf("\na fonksiyonunun kapsamındayız. x = %d\n", x);
    ++x;
    printf("hala a'dayız ve x'i 1 arttırdık (++x). şu anda x = %d\n", x);
}
void b(void){
    static int x = 50; /* bu x değişkeni durağan tanımlı, yerel bir değişken.
    ilk çapırıldığında belleğe yerleşir ve bu satırdaki ilk değer atama
    işlemi yalnızca fonksiyon ilk çalıştığında geçerlidir. */
    printf("\nb fonksiyonunun kapsamındayız. x = %d\n", x);
    x = x + 2;
    printf("hala b'deyiz ve x'i 2 arttırdık. şu anda x = %d\n", x);
}
void c(void){
    printf("\nb fonksiyonunun kapsamındayız. x = %d\n", x);
    x = x * 2;
    printf("hala b'deyiz ve x'i 2 ile çarptık. şu anda x = %d\n", x);
}
#+END_SRC

* Özyineleme (Recursion):

bir fonksiyonun kendi kendini çağırarak çalışmasına /özyineleme/, bu şekilde
çalışan fonksiyonlara ise /özyinelemeli/ (/recursive/) fonksiyonlar denir.
Özyineleme, döngüler gibi tekrarlı yapıların yerine kullanılabilecek oldukça
güçlü bir programlama tekniğidir. Özyinelemeli bir algoritmada tekrarlar
fonksiyonun kendisini kopyalayarak çağırması ile elde edilir ve bu kopyalar
bittiğinde (normal fonksiyon çağırımlarında olduğu gibi esasında) bellekten
silinirler.

Bir problemi özyineleme ile çözebilmemiz için problemi iki ana parçaya
ayırmamız gerekir:
1) Cevabı kesin olarak bilinen bir *temel durum* (base case)
2) Cevabı bilinmeyen fakat cevabı *problemin kendisi kullanılarak*
bulunabilecek durum.

Faktöriyel alma işlemini, özyineleme bakış açısıyla ele alabiliriz.
Faktöriyeli tanımlamamız gerekirse; herhangi bir doğal sayının (0 hariç)
faktöriyeli, birden başlayarak o sayıya kadarki tüm doğal sayıların
çarpımıdır.

: N! = 1 * 2 * ... * (N - 1) * N

Sıfırın faktöriyeli, 1'dir.

: 0! = 1

Eğer bu işlemdeki son sayıyı yani N'i ayırırsak işlemi şu şekilde de
yapabiliriz:

: N! = N * (N - 1)!

Bu mantığı programlama çerçevesinde düşündüğümüzde, N!'in ilk ve ikinci
gösterimleri bize özyineleme için ihtiyaç duyduğumuz 2. durumu sağlar: cevabı
bilinmeyen ama cevabı problemin kendisi kullanılarak bulunabilen durum yani
N! yerine (N - 1)! * N kullanmamız bizi cevaba götürmez, cevabı yine
problemin kendisi ile çözülebilen yeni bir durum yaratır. Burada temel
durumumuz ise cevabu kesin olarak bilinen durum yani 0! durumudur.

Döngüler kullanılarak bir faktöriyel hesaplama fonksiyonu şu şekilde
yazılabilir:

#+BEGIN_SRC c
long faktoriyelHesabi(int n){
    long faktoriyel = 1, i;
    for (i = 1; i <= n; i++)
        faktoriyel = faktoriyel * i;
    return faktoriyel;
}
#+END_SRC

Özyinelemeli bir fonksiyonun akış şemasını incelediğimizde mantığını daha iyi
kavrayabiliriz. Mesela 5 faktöriyeli hesaplamak için özyinelemeli bir
fonksiyon şu şekilde bir akış izler:

: 5 faktoriyeli bul
: (5! = 5 * 4!) ==> 4 faktoriyeli bul
: (4! = 4 * 3!) ==> 3 faktoriyeli bul
: (3! = 3 * 2!) ==> 2 faktoriyeli bul
: (2! = 2 * 1!) ==> 1 faktoriyeli bul
: (1! = 1 * 0!) ==> 0 faktoriyeli bul
: (0! = 1) ==> Temel duruma kadar indik

Aranan ve bulunan her bir değer bir üstteki yerine yazılırsa sonuçta 5
faktöriyele ulaşılacaktır. Yani n == 0 ise 1 return edip değilse n'i aynı
fonksiyona n-1 vererek alınan değerle çarptığımızda, en sonunda 5 faktöriyeli
elde ederiz. Programa döktüğümüzde ise şöyle olur:

#+BEGIN_SRC c
long faktoriyelHesabi(int n){
    if (n == 0)
        return 1;
    else
        return n * faktoriyelHesabi(n - 1);
}
#+END_SRC

Fonksiyonlar özyineli olarak her çalıştığında yerel değişkenler ve
parametreler bellekten ayrılır. Her fonksiyondan çıkışta söz konusu
fonksiyonun değişkenleri için bellekte ayrılan yerler serbest kalır ve bir
önceki kopya yeniden etkinleştirilir. C dili bu işlemi "/yığın/" (stack)
olarak gerçekleştirir. Her fonksiyon çağırımında fonksiyonun değişkenleri
yığının en üstüne konur ve fonksiyondan çıkıldığında enson eklenen eleman
çıkarılır. En son işlem görecek olan fonksiyon, ilk giren fonksiyondur.

Özyinelemeye başka bir örnek de fibonacci sayılarıdır. Fibonacci dizisinde 0
ve 1. elemanlar hariç tüm elemanlar, kendisinden önceki iki elemanın toplamı
şeklinde yazılabilmektedir. Bu durumda f(0) ve f(1) durumları temel durum
olacaktır. Her elemandan bir önceki sayı da kendinden önceki son iki sayının
toplamı şeklinde yazılabilir. Bu da bizim cevabı olmayan ama problemin
kendisi ile cevabı bulabilen durumumuz. yani f(a) = f(a-1) + f(a-2) olur.

Aşağıdaki fonksiyon, istenen sıradaki bir fibonacci sayısını verir:
#+BEGIN_SRC c
long fib(int a){
    if (a == 0 || a == 1)
        return a;
    else
        return fib(a - 1) + fib(a - 2);
}
#+END_SRC

Fonkyionun çalışma şemasını, a = 4 için inceleyelim:

:             |main()|
:                |
:                ▼
:             |fib(4)|
:             /     \
:            /       \
:           ▼        ▼
:       |fib(3)| + |fib(2)|
:        /     \       |   |
:       /       \      |   ------|
:      ▼        ▼      ▼         ▼
: |fib(2)| + |fib(1)| |fib(1)| + |fib(0)|
:  |    |
:  |    ------|
:  ▼          ▼ 
: |fib(1)| + |fib(0)|

* Diziler (Arrays)

Tek bir isim (değişken) altında *aynı türde* birden fazla değer tutmak için
kullanılan veri yapılarıdır. Diziler esasında bir kümedir. Dizi içersindeki
her bir veriye de /eleman/ adı verilir. Bir dizinin tüm elemanları, bellekte
ardışık olarak saklanır. Çok boyutlu veya tek boyutlu dizilerden bahsetmek
mümkündür.

** Tek boyutlu diziler:

C99 öncesi C standartlarına göre dizinin eleman sayısı ya belli bir sayı ya
da önceden *#define* önişlemci direktifi ile tanımlanmış sembolik bir sabit
olmalıdır, bir değişken olamaz. C99 standardı ile birlikte artık dizilerin
eleman sayıları değişken olabilmektedir. Tek boyutlu bir dizi oluşturmak için
syntax şu şekildedir:

: dizinTürü dizinAdı [elemanSayısı];

Bir kaç örnekle gösterelim:
#+BEGIN_SRC c
int sayiDizisi[6] /* 6 elemanlı, int'lerden oluşan dizi */
char karakterDizisi[10] /* 10 elemanlı, char'lardan oluşan bir dizi */
#+END_SRC

Dizi içersindeki her bir elemana dizi isminden sonra yazılan pozisyon
numarası yani indis değeri ile ulaşılır. İndis değerleri her zaman tamsayıdır
ve tüm dizilerde indis numarası *sıfırdan başlar*.

| indis         | eleman    |
|---------------+-----------|
| sayiDizisi[0] | 1. Eleman |
| sayiDizisi[1] | 2. Eleman |
| sayiDizisi[2] | 3. Eleman |
| sayiDizisi[3] | 4. Eleman |
| sayiDizisi[4] | 5. Eleman |
| sayiDizisi[5] | 6. Eleman |

*** Tek boyutlu dizilere eleman atanması:

Dizinin elemanlarına ulaşmak için dizinin ismi ve köşeli parantez içersinde
indis numarasının yazılması yeterli olmaktadır. *sayiDizisi* dizisine
aşağıdaki gibi değerler atanabilir:

#+BEGIN_SRC c
sayiDizisi[0] = 10; /* 0 numaralı indise 10 değerini atadık */
#+END_SRC

*** Tek boyutlu dizilere ilk değer atanması:

Dizilere yukarıdaki gibi tek tek değer ataması yapmak yerine diziyi
tnaımlarken {} kullanarak ilk değer ataması da yapılabilir. Örnek vermek
gerekirse:

#+BEGIN_SRC c
int sayilar[5] = {2, 4, 3, 5, 8};
#+END_SRC

Bu tanımladığımız dizi şöyle olacaktır:

| indis      | eleman |
|------------+--------|
| sayilar[0] | 2      |
| sayilar[1] | 4      |
| sayilar[2] | 3      |
| sayilar[3] | 5      |
| sayilar[4] | 8      |

Belirtilen eleman sayısından daha fazla eleman verildiğinde hata alınır. Daha
az eleman verildiğinde ise (int dizileri için) atanmayan elemanlara 0 atanır.
İlk değer ataması yapılmayan dizilerin elemanları, bellekteki rastgele
değerlerden oluşur. Eğer dizi *static* ya da global olarak tanımlanmış ise
ilk değer ataması yapılmadığında elemanların değerleri sıfır olarak veya boş
olarak atanır.

İlk değer ataması yapılırken *eleman sayısının verilmesi zorunlu değildir*.
Bu durumda, kaç değer eleman olarak atanmışsa dizinin uzunluğu o kadar olur.

: int a[5] = {4,5}; | int a[5] = {0}; | int a[5];    | int a[] = {5, 4, 3};
: a[0]     4        | a[0]     0      | a[0]    rand | a[0]    5
: a[1]     5        | a[1]     0      | a[1]    rand | a[1]    4
: a[2]     0        | a[2]     0      | a[2]    rand | a[2]    3
: a[3]     0        | a[3]     0      | a[3]    rand |
: a[4]     0        | a[4]     0      | a[4]    rand |

Dizilerin kullanımına bir örnek olması açısından, yazılan 5 adet sayıyı,
sondan başa sıralayan bir program yazalım:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int sayilar[5]; /* 5 elemanlı bir tamsayı dizisi */
    int i;
    printf("5 adet sayı giriniz: \n");
    for (i = 0; i < 5; i++)
        scanf("%d", &sayilar[i]);
    printf("Girilen sayilarin sondan basa siralamasi: \n");
    for (i = 4; i >= 0; i--)
        printf("%d\n", sayilar[i]);
    return 0;
}
#+END_SRC

Tek boyutlu bir dizide eleman atanması için bir başka syntax da şudur:

#+BEGIN_SRC c
int dizi[5] = {[0] = 2, [3] = 4};
#+END_SRC

Bu şekilde tanımlanan bir dizide 0. indeks 2, 3. indeks 4 olacaktır. Diğer
indeksler veri türüne bağlı olarak 0 veya boş atanabilir. Genel kullanımda
pratik olmadığı için fazla karşılaşılmasa da ilk atamada elemanları sıralı
atamak istemediğimizde kullanılabilecek bir syntaxdır.

** Dizilerin sıralanması:

Söz konusu dizi elemanlarının sıralanması olduğunda pek çok farklı algoritma
kullanılmaktadır. Bunlar arasında kabarcık sıralama (bubble sort), seçme
sıralama (selection sort), kabuk sıralama (shell sort), çabuk sıralama (quick
sort) sayılabilir. Bunlar arasında en sık kullanılan ve en pratik
algoritmalardan biri *kabarcık sıralama* algoritması, bir başkası da
*seçme sıralama* algoritmasıdır..

*** Kabarcık sıralama (bubble sort):

Kabarcık sıralamada her bir eleman kendisinden bir sonraki eleman ile
karşılaştırılır. Karşılaştırma büyüklük sorgulaması şeklinde yapıldığında
dizi küçükten büyüğe; küçüklük sorgulaması yapıldığında ise büyükten küçüğe
sıralanır. Eğer karşılaştırma koşuluna uyuyorsa iki elmanın yerleri
değiştirilir. Değiştirme işlemi için bir yedek değişken kullanılmalıdır. Bu
işlem, dizinin eleman sayısının 1 eksiği defa tekrarlanır. Elemanlar son
tekrardan önce sıralanmış olsa da eleman sayısının 1 eksiği kadar
tekrarlandığında dizinin sıralandığı garanti altına alınır.

Aşağıda 5 elemanlı bir dizinin sıralanması ile algoritmayı inceleyebiliriz:

[[./resimler/bubble_sort.jpg]]

Söz konusu algoritmanın koda uygulanması ise aşağıdaki gibi olur:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int n[5] = {13, 12, 0, 5, 8};
    int i,j;
    int yedek;
    printf("Dizinin sirasiz hali: \n");
    for (j = 0; j < 5; j++)
        printf("%d\t", n[j]);

    for (i = 1; i < 5; i++){// i geçişler için. 5 eleman için 4 geçiş yapıyoruz.
        for (j = 0; j < 5-1; j++){ 
            if (n[j] > n[j+1]){
                yedek = n[j];
                n[j] = n[j+1];
                n[j+1] = yedek;
            }
        }
    }
    printf("\nDizinin sıralı hali: \n");
    for (j = 0; j < 5; j++)
        printf("%d \t", n[j]);
    return 0;
}
#+END_SRC

Kod çalıştırıldığına dizinin küçükten büyüğe sıralandığı görülebilir.

*** Seçme sıralaması (selection sort):

Seçme sıralamasında kabarcık sıralamasından farklı olarak her geçişte, bir
indisin en küçük elemana sahip olduğu farz edilir ve bu eleman kendisinden
sonrakilerle kıyaslanır. Kıyaslama esnasında bulunan en küçük eleman, söz
konusu indise atanır. Kodda görmek daha faydalı olacaktır:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int dizi[5] = {13, 12, 0, 5, 8};
    int i, k, m, enKucuk, yedek;
    printf("Dizinin ilk hali: \n");
    for (i = 0; i < 5; i++)
        printf("%d\n", dizi[i]);
    for (k = 0; k < 5-1; k++){
        enKucuk = k;
        for (m = k+1; m < 5; m++){
            if (dizi[m] < dizi[enKucuk])
                enKucuk = m;
        }
        yedek = dizi[k];
        dizi[k] = dizi[enKucuk];
        dizi[enKucuk] = yedek;
    }
    printf("Dizinin yeni hali: \n");
    for (i = 0; i < 5; i++)
        printf("%d\n", dizi[i]);
}
#+END_SRC

** Dizilerde eleman aranması:

Dizilerde bahsi geçen arama, belli bir değerin dizi içersinde var olup
olmadığını belirleme işlemidir. Sıralama işleminde olduğu gibi arama işlemi
için de pek çok farklı algoritma geliştirilmiştir. Bunlardan en sık
kullanılanları linear (doğrusal) arama ve binary (ikili) aramadır.

*** Doğrusal (linear) arama:
Doğrusal aramada listenin elemanları teker teker aranan değerle
karşılaştırılır. Aranan değere eşit bir elemanla karşılaşıldığında bu
elemanın indis numarası, daha önce tanımlanmış bir yer değişkenine atanarak
elemanın yeri de daha sonra kullanılmak üzere tutulabilir. Aşağıdaki örnek
kodda doğrusal arama yoluyla eleman aramayı görebiliriz:

#+BEGIN_SRC c
#include <stdio.h>
int main(){
    int n[5] = {13, 12, 0, 5, 8};
    int i;
    int aranan;
    int yer = -1; // var olmadığı kesin olarak bilinen bir indis atanarak
    // elemanın bulunmaması durumundaki yer değişkeni belirlenir.

    printf("Aranacak elemanı giriniz: ");
    scanf("%d", &aranan);

    for (i = 0; i < 5; i++){
        if (n[i] == aranacak)
            yer = i;
    }
    if (yer != -1)
        printf("Aranilan deger, dizide %d numaralı indiste bulunmaktadır.", yer)
    else
        printf("Aranılan eleman dizide bulunamamıştır.")

    return 0;
}
#+END_SRC

*** İkili (binary) arama:
Konsept olarak doğrusal arama kadar basit değildir fakat dizilerde eleman
aranmasında ortalama olarak doğrusal aramaya göre daha hızlıdır (bkz. Python
örnekleri; fonksiyonlar/recursion_denem.py). Önce listenin sıralanmış bir
hali oluşturulur ve ardından fonksiyon, her bir aramada aranan sayıyı, 
ortadaki sayı ile karşılaştırır. Eğer ortadaki sayıdan büyükse dizinin
sağında, küçükse solunda (dizinin küçükten büyüğe sıralandığı farz edilirse)
aramaya devam eder.

#+BEGIN_SRC c
#include <stdio.h>
int ikiliAra(int [], int, int);
int kabarcikSirala(int [], int);
int main(){
    int dizi[10] = {1, 34, 12, 65, 34, 5, 78, 0, 3, 29};
    printf("Dizinin siralanmis halinde 5 sayisi %d. indistedir.", ikiliAra(dizi, 10, 5));
}
int ikiliAra(int dizi[], int n, int aranan){
    int bas = 0;
    int son = n-1;
    int orta;
    kabarcikSirala(dizi, n);
    while (bas <= son){ // kontrol koşulu. bu durumda tüm elemanlar kontrol edilmiş olur.
        orta = (bas + son) / 2; // dizinin baştaki orta indisi
        if (dizi[orta] == aranan) // eğer orta indisteki aranan sayiysa return et
            return orta;
        else if (dizi[orta] > aranan) // aranan sayidan buyukse, aramanin sonunu ortanin bir eksigi yap cunku sirali dizide bundan daha buyuk sayilara bakmaya gerek yok
            son = orta - 1;
        else // benzer sekilde aranan orta nokta aranan sayidan kucukse bundan daha kucuklere bakmaya gerek yok o yuzden baslangici ortanin bir buyugu yap
            bas = orta + 1;
    } // bunu ozyineleme ile de yapmak mumkun aslinda uzerine calis

    return -1; // buraya kadar bir deger return edilememisse bulunamamistir.
}
int kabarcikSirala(int dizi[], int n){
    int i, j;
    int yedek;
    for (i = 0; i < n-1; i++)
        for (j = 0; j < n-1; j++)
            if (dizi[j] > dizi[j+1]){
                yedek = dizi[j];
                dizi[j] = dizi[j+1];
                dizi[j+1] = yedek;
            }
}
#+END_SRC

** Dizilerin fonksiyonlarda parametre olarak kullanılması:

Bir dizi, fonksiyona parametre olarak gönderilmek istendiğinde fonksiyon
*çağırılırken* yalnızca dizinin adı yazılır. Fonksiyonun *başlığında* ise
verilen parametrenin dizi olduğunu tanımlamak için köşeli parantezler
kullanılır. Dizi tanımlamada olduğu gibi fonksiyon tanımlarında dizilerin
parametre olarak verilmesinde de parantezler içine eleman sayısı yazılmasına
gerek yoktur. Eğer uygun bir eleman sayısı verilmezse derleyici hata verir
fakat uygun bir eleman sayısı verilirse derleyici tarafından göz ardı edilir
ve fonksiyona parametre olarak verilen eleman sayısı tanımlanırken
kullanılandan farklı da olsa hata alınmaz. Dizi ile yapılabilecek hemen her
işlemde, dizinin eleman sayısı kullanılmaktadır. Bu sebeple çoğunlukla
dizileri fonksiyonlarda parametre olarak kullanırken ikinci bir parametre
olarak da dizinin eleman sayısı istenir ve verilir. Bir örnek görelim:

#+BEGIN_SRC c
#include <stdio.h>
void diziYazdir(int [], int);
int main(){
    int sayilar[5] = {1, 2, 3, 4, 5};
    diziYazdir(sayilar, 5);
    return 0;
}
void diziYazdir(int a[], int n){
    int i;
    for (i = 0; i < n; i++)
        printf("%d ", a[i]);
}
#+END_SRC

Daha önce fonksiyonlarda Bağlantılı Çağırım ve Değerlerle Çağırımdan
bahsetmiştik. Diziler fonksiyonlara parametre olarak gönderilirken
*bağlantılı çağırma* ile gönderilirler. Bu tip bir çağırmada, değerlerin
kopyalandığı değişkenlerin değiştirilmesi, orijinal değeri de değiştirir.
Yani yukarıdaki örneği ele alacak olursak; *sayilar* dizisini fonksiyon
çağırımında karşılayan *a* dizisini değiştirdiğimizde, *sayilar* dizisi de
değiştirilir. 

Burada verilerin bellek yerleşimine değinmek gerekir. Bir verinin bellekteki
yerini görmek için *%p* yertutucusu kullanılır. Bir dizinin bellekteki yerine
bu yertutucu ile bakabiliriz. Dizinin elemanları ise bir bellek hücresi
yerine, başka bir bellek hücresinin sıralı alt hücreleri olarak çıktı
verecektir çünkü bir dizinin ardışık elemanları, dizinin kendisinden sonraki
hücrelere ardışık olarak yerleştirilirler (Program diziler/bellek_yapisi.c).
Bir fonksiyona parametre olarak bir diziyi verip, bu fonksiyon altında hangi
bellek hücresi içersinde olduğuna baktığımızda, aslında aynı bellek hücresini
işgal eden veriler olduğu yani temelde *aynı veriler* olduğu örnek programda
görülebilir (bellekteki yerlerle ilgili alınan çıktılar DOS, UNIX ve
UNIX-like sistemlerde birbirinden farklı olabilir). UNIX-like sistemlerde bir
*int* değeri 4 bit olduğu için örnek programın çıktılarında ardışık dizi
elemanlarının bellekteki başlangıç yerleri arası fark her zaman 4 bit
olmaktadır.

Dizilerdeki elemanların bağlantılı çağırım özelliğine bağlı olarak
değiştirilmesi ile ilgili örnek de aynı programda görülebilir. Burada
değiştirilen elemanın tutulduğu bellek hücresi değişmemesine rağmen, elemanın
değerinin değiştiği görülebilmektedir.

** Çok boyutlu diziler (multiply subscripted arrays):

Elemanlarına ancak birden fazla indis numarası ile ulaşılabilen dizilere, çok
boyutlu diziler denir. Teorik olarak her boyutta dizi tanımlanabilir; mesela
üç boyutlu uzayı temsil eden bir hesaplama modelinde 3 boyutlu diziler,
zamanı da içine alan bir uzayı temsil eden bir hesaplama modelinde 4 boyutlu
diziler kullanılabilir fakat en sık kullanılan /çift boyutlu diziler/dir
(double subscripted arrays). Bu diziler sayesinde değerler, bir tablodaki
verilere benzetilir. Bellekte yine ardışık olarak tutulurlar fakat
çağırımları ve modellemeleri tablolara veya matematiksel matrislere benzer.
Çok boyutlu dizilerde her bir elemana ulaşmak için elemanın bir satır indisi
(row) ve sütun indisi (column) kullanılır. Teorik bir sınır olmamasına karşın
C dili ancak 12 boyuta kadar dizileri destekler. Çift boyutlu dizilerin
syntaxı:

: dizininTürü dizininAdı [satırSayısı][sütunSayısı]

Örneğin:

#+BEGIN_SRC c
int a[3][4]; // 3 satırlı, 4 sütunlu iki boyutlu bir tamsayı dizisi.
float b[5][3]; // 5 satırlı, 3 sütunlu bir ondalıklı sayı dizisi.
#+END_SRC

Örnekte verilen ilk dizinin değerlerine ulaşmamız gereken indis numaralarını
bir tablo ile gösterebiliriz:

|         | Sütun 0 | Sütun 1 | Sütun 2 | Sütun 3 |
|---------+---------+---------+---------+---------|
| Satır 0 | a[0][0] | a[0][1] | a[0][2] | a[0][3] |
| Satır 1 | a[1][0] | a[1][1] | a[1][2] | a[1][3] |
| Satır 2 | a[2][0] | a[2][1] | a[2][2] | a[2][3] |

*** Çift boyutlu dizilere ilk değer atanması:

İlk değer ataması esasında tek boyutlu dizilerden faklı değildir. Satır
sayısını veren kısım ilk diziolarak düşünülürse, yukarıdaki örnek için 4
elemanlı diziler içeren 3 elemanlı bir dizi olarak atama yapılır:

#+BEGIN_SRC c
int a[3][4] = {{1, 3, 2, 4}, {0, 2, 5 ,1}, {9, 5, 7, 2}};
// veya daha okunaklı olması için
int a[3][4] = { {1, 3, 2, 4},
                {0, 2, 5 ,1},
                {9, 5, 7, 2} }; // şeklinde de atama yapılabilir.
#+END_SRC

Yine tek boyutlu dizilere benzer şekilde, eleman sayısından daha az eleman
girilirse atanmayan elemanlar /veri tipine bağlı olarak/ sıfır veya boş
olarak atanır. İçteki küme işaretleri olmadan yapılan bir atamada ise
elemanlar ilk hücreden itibaren sıra ile yerleştirilir fakat kodun okunurluğu
açısından çok tercih edilen bir syntax değildir. Yukarıda tanımlanmış olan
iki boyutlu dizi aşağıdaki gibi bir tabloda gösterilebilir:

| indisler | 0 | 1 | 2 | 3 |
|----------+---+---+---+---|
| 0        | 1 | 3 | 2 | 4 |
| 1        | 0 | 2 | 5 | 1 |
| 2        | 9 | 5 | 7 | 2 |

Örnek bir programda, 4x6'lık bir dizideki sütun toplamlarını ekrana
yazdıralım. Bu programda, satır ve sütun sayısını *define* önişlemci
direktifi ile sabit sayılar olarak atayalım:

#+BEGIN_SRC c
#include <stdio.h>
#define R 4
#define C 6
int main(){
    int a[R][C];
    int sutun[C] = {0}; // tum sutunlarda ilk toplam degerler 0 olarak atansin
    int i,j;

    for (i = 0; i < R; i++){
        printf("%d. satirdaki elemanlari giriniz: ", i);
        for (j = 0; j < C; j++)
            scanf("%d", &a[i][j]);
    }
    for (i = 0; i < R; i++)
        for (j = 0; j < C; j++)
            sutun[j] = sutun[j] + a[i][j];
    // bu dongunun sonunda sutun dizisi, her bir sutunun toplamini sirayla iceren bir dizi olacak
    printf("---------------\n");
    for (j = 0; j < C; j++)
        printf("%d. sutunun toplami %d\n", j, sutun[j]);
    return 0;
}
#+END_SRC

*** Çok boyutlu dizilerin fonksiyonlarda parametre olarak kullanılması:

Çok boyutlu diziler de tek boyutlu dizilerde olduğu gibi fonksiyonlara
parametre olarak verilirken yalnızca isimleri ile verilirler. Fonksiyona
verilecek diziler tanımlanırken, dizinin boyutu kadar köşeli parantez çifti
ile verilmelidir. Bu tanımlamalar yapılırken en dıştaki dizinin boyutunun
verilmesine gerek yoktur fakat iç dizilerin boyutları, fonksiyon
tanımlanmasında belirtilmelidir. Örneğin:
#+BEGIN_SRC c
int dizi[3][4] = { {1, 2, 3, 4},
                   {5, 6, 7, 8},
                   {2, 4, 6, 8} };
void diziYaz( int a[][4] ){
    // kod bloğu
}
/* Bu kullanım doğru olsa da aşağıdaki esasında daha uygun bir kullanım */
void diziYaz( int a[3][4] ){
    // kod bloğu
}
#+END_SRC

Çok boyutlu dizilerin bellek yapısı tek boyutlu dizilerle esasen aynıdır.
Elemanlar tek boyutlu dizilerde olduğu gibi sıra ile bellek hücrelerine
yerleştirilirler. Bunun bir örneğini *diziler/coklu_dizi_bellek_yapisi.c*
kodunun çalıştırılmasıyla görebiliriz. İlk boyutun yani iki boyutlu diziler
için satır sayısının verilmesine gerek olmasa da diğer boyutlarının eleman
sayısının verilmesinin gerekliliği buradan doğar; derleyici bir sonraki
satırın başlangıçtan kaç eleman sonra başlayacağını sütun sayısından anlar.
